<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>dp学习笔记3——区间dp（作业表3总结）</title>
    <link href="/2024/01/12/dp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4dp%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%A1%A83%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <url>/2024/01/12/dp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%8C%BA%E9%97%B4dp%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%A1%A83%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>主要针对于区间 dp 的总结。</p><p>比较拿手（感觉有一种抽象的无从下手但又很智慧的美）</p><h1 id="原理">原理</h1><p>对于一个大区间，如果我们可以解决他的子区间问题，并且答案还能合并到大区间里，那这个问题就可以用区间dp 解决。</p><p>就这么简单，但是扩展出去有亿点复杂。</p><h1 id="例题">例题</h1><h2 id="k-祖玛游戏">K 祖玛游戏</h2><p><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=2572&amp;tid=K">LinkNKOJ</a> and <a href="https://www.luogu.com.cn/problem/P5189">LinkLougu</a></p><p>一道经典题目（也开始难了）。</p><p>首先，我们现设 <span class="math inline">\(dp_{i,j}\)</span>是消除区间 <code>[i,j]</code>所用的最小弹珠数，如果直接开始枚举断点，我们会发现两个区间可能会有多次的不相邻的消除，是比<span class="math inline">\(dp_{i,j}\)</span> 只消一次的结果更优。</p><p>我们考虑增加一个维度：设 <spanclass="math inline">\(dp_{i,j,k}\)</span> 是消除区间 <code>[i,j]</code>以及前面有 <span class="math inline">\(k\)</span>个相同的弹珠所用的最小弹珠数。</p><p>开始分类讨论：</p><ul><li>情况一：第 <span class="math inline">\(i\)</span> 个弹珠与第 <spanclass="math inline">\(i+1\)</span> 个弹珠颜色相同，那显然消除<code>[i,j]</code> 的弹珠花费比消除 <code>[i+1,j]</code> 的花费少 <spanclass="math inline">\(1\)</span>，所以 <spanclass="math inline">\(dp_{i,j,k}\)</span> 可以更新为 <spanclass="math inline">\(dp_{i+1,j,k+1}\)</span>。</li><li>情况二：我们在第 <span class="math inline">\(i\)</span>个弹珠的前面再放一个与其同色的弹珠，花费增加了 <spanclass="math inline">\(1\)</span>，所以 <spanclass="math inline">\(dp_{i,j,k}\)</span> 可以更新为 <spanclass="math inline">\(dp_{i,j,k+1}+1\)</span>。</li><li>情况三：我们考虑枚举一个断点 <spanclass="math inline">\(l\)</span>，如果说 <spanclass="math inline">\(l+1\)</span> 的颜色与 <spanclass="math inline">\(i\)</span> 的颜色相等，我们可以将区间<code>[i+1,l]</code> 的弹珠全部消完，再将 <spanclass="math inline">\(i\)</span> 与 <spanclass="math inline">\(l+1\)</span> 连接起来消，所以 <spanclass="math inline">\(dp_{i,j,k}\)</span> 可以被更新为 <spanclass="math inline">\(dp_{i+1,j,0}+dp_{l+1,j,l+1}\)</span>。</li></ul><p>注意要对 <span class="math inline">\(k = K - 1\)</span>时特殊处理，因为它在添加 <span class="math inline">\(1\)</span>个弹珠就可以消完了。</p><h3 id="ac-code">AC code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">110</span>;<br><span class="hljs-type">const</span> ll K=<span class="hljs-number">5</span>+<span class="hljs-number">10</span>;<br>ll n,kk;<br>ll a[N];<br>ll dp[N][N][K];<span class="hljs-comment">//[i,j],前跟k</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;kk;<br><span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x3f</span>,<span class="hljs-built_in">sizeof</span>(dp));<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;a[i];<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">0</span>; j&lt;kk; j++) &#123;<br>dp[i][i][j]=kk-j<span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll k=<span class="hljs-number">2</span>; k&lt;=n; k++) &#123;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n-k+<span class="hljs-number">1</span>; i++) &#123;<br>ll j=i+k<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(ll l=kk<span class="hljs-number">-1</span>; l&gt;=<span class="hljs-number">0</span>; l--) &#123;<span class="hljs-comment">//前跟多少</span><br><span class="hljs-keyword">if</span>(a[i]==a[i+<span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//情况一</span><br>dp[i][j][l]=<span class="hljs-built_in">min</span>(dp[i][j][l],dp[i+<span class="hljs-number">1</span>][j][<span class="hljs-built_in">min</span>(l+<span class="hljs-number">1</span>,kk<span class="hljs-number">-1</span>)]);<br>&#125;<br>                 <span class="hljs-keyword">if</span>(l==kk<span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">//对于 k-1 的特殊考虑</span><br>dp[i][j][l]=<span class="hljs-built_in">min</span>(dp[i][j][l],dp[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]);<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//情况二</span><br>dp[i][j][l]=<span class="hljs-built_in">min</span>(dp[i][j][l],dp[i][j][<span class="hljs-built_in">min</span>(l+<span class="hljs-number">1</span>,kk<span class="hljs-number">-1</span>)]+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(ll l_=i+<span class="hljs-number">1</span>; l_&lt;j; l_++) &#123;<br><span class="hljs-keyword">if</span>(a[i]==a[l_+<span class="hljs-number">1</span>]) &#123;<span class="hljs-comment">//情况三</span><br>dp[i][j][l]=<span class="hljs-built_in">min</span>(dp[i][j][l],dp[i+<span class="hljs-number">1</span>][l_][<span class="hljs-number">0</span>]+dp[l_+<span class="hljs-number">1</span>][j][<span class="hljs-built_in">min</span>(l+<span class="hljs-number">1</span>,kk<span class="hljs-number">-1</span>)]);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;dp[<span class="hljs-number">1</span>][n][<span class="hljs-number">0</span>]&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="o-haoi2016字符合并">O [HAOI2016]字符合并</h2><p><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=2572&amp;tid=O">LinkNKOJ</a> and <a href="https://www.luogu.com.cn/problem/P3736">LinkLougu</a></p><p>一道状压+区间。</p><p>我们看到一个叫<strong>合并</strong>的操作，很明显就想到了可以用区间dp 来做，而且 <span class="math inline">\(k\)</span>小的不能再小了，干脆直接枚举其合并后的状态（小于等于 <spanclass="math inline">\(k\)</span> 位，<spanclass="math inline">\(2^k\)</span> 就行）。</p><p>我们设 <span class="math inline">\(dp_{i,j,S}\)</span> 为<code>[i,j]</code> 区间合并后所得到的字符串为 <spanclass="math inline">\(S\)</span>的最大分数，然后有一个性质，见我之前写的<ahref="https://rqdyc.github.io/2023/11/25/Luogu-P3736-HAOI2016-字符合并-题解/">题解</a>，可以来进行优化，然后dp 方程就很简单了，如果说我要合并 <code>[i,k]</code> 和<code>[k,j]</code>，我就用 <code>[i,k]</code> 的状态合并<code>[k,j]</code> 的状态，然后因为 <code>[i,k]</code>的信息足够丰富了，我们就可以将 <code>[k,j]</code> 合并为了 <spanclass="math inline">\(1\)</span> 或 <spanclass="math inline">\(0\)</span> 的情况，效果都一样。然后长度到 <spanclass="math inline">\(k\)</span> 之后就可以合并为 <spanclass="math inline">\(1\)</span> 或 <spanclass="math inline">\(0\)</span>，要看其具体数值。</p><p>总体而言思维难度比 K 题简单太多。</p><h3 id="ac-code-1">AC code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">310</span>;<br><span class="hljs-type">const</span> ll K=<span class="hljs-number">7</span>;<br><span class="hljs-type">bool</span> sum[N];<br><span class="hljs-function">ll <span class="hljs-title">getsum</span><span class="hljs-params">(ll i,ll j)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(i&gt;j)<span class="hljs-built_in">swap</span>(i,j);<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll k=j,q=<span class="hljs-number">0</span>; k&gt;=i; k--,q++) &#123;<br>ans+=(sum[k])*(<span class="hljs-number">1</span>&lt;&lt;q);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">wes</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> ll x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">32</span>-__builtin_clz(x);<br>&#125;<br><span class="hljs-comment">//调试 </span><br>ll n,kk;<br>ll dp[N][N][<span class="hljs-number">1</span>&lt;&lt;(K+<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>];<br>ll str[<span class="hljs-number">1</span>&lt;&lt;(K+<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>];<br><span class="hljs-type">bool</span> tr[(<span class="hljs-number">1</span>&lt;&lt;(K+<span class="hljs-number">1</span>))|<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;kk;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>; j&lt;=n; j++) &#123;<br><span class="hljs-keyword">for</span>(ll s=(<span class="hljs-number">1</span>&lt;&lt;kk)<span class="hljs-number">-1</span>; s&gt;=<span class="hljs-number">0</span>; s--) &#123;<br>dp[i][j][s]=<span class="hljs-number">-1145141919810ll</span>;<span class="hljs-comment">//初始化 </span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;sum[i];<br>dp[i][i][sum[i]]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=(<span class="hljs-number">1</span>&lt;&lt;kk); i++) &#123;<br>cin&gt;&gt;tr[i<span class="hljs-number">-1</span>]&gt;&gt;str[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(ll k=<span class="hljs-number">2</span>; k&lt;=n; k++) &#123;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n-k+<span class="hljs-number">1</span>; i++) &#123;<br>ll j=i+k<span class="hljs-number">-1</span>;<br>ll sizee=(k<span class="hljs-number">-1</span>)%(kk<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(sizee==<span class="hljs-number">0</span>) &#123;<br>sizee=kk<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(ll l=j<span class="hljs-number">-1</span>; l&gt;=i; l-=(kk<span class="hljs-number">-1</span>)) &#123;<br><span class="hljs-keyword">for</span>(ll s=(<span class="hljs-number">1</span>&lt;&lt;(sizee))<span class="hljs-number">-1</span>; s&gt;=<span class="hljs-number">0</span>; s--) &#123;<br>dp[i][j][s&lt;&lt;<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][s&lt;&lt;<span class="hljs-number">1</span>],dp[i][l][s]+dp[l+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]);<br>dp[i][j][s&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][s&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>],dp[i][l][s]+dp[l+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(sizee==kk<span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">//合并后的长度为1</span><br>ll r[<span class="hljs-number">2</span>];<br>r[<span class="hljs-number">0</span>]=r[<span class="hljs-number">1</span>]=<span class="hljs-number">-1145141919810ll</span>;<br><span class="hljs-keyword">for</span>(ll s=(<span class="hljs-number">1</span>&lt;&lt;kk)<span class="hljs-number">-1</span>; s&gt;=<span class="hljs-number">0</span>; s--) &#123;<br>r[tr[s]]=<span class="hljs-built_in">max</span>(r[tr[s]],dp[i][j][s]+str[s]);<br>&#125;<br>dp[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">0</span>],r[<span class="hljs-number">0</span>]);<br>dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">1</span>],r[<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>ll ans=<span class="hljs-number">-1145141919810ll</span>;<br><span class="hljs-keyword">for</span>(ll s=(<span class="hljs-number">1</span>&lt;&lt;kk)<span class="hljs-number">-1</span>; s&gt;=<span class="hljs-number">0</span>; s--) &#123;<br>ans=<span class="hljs-built_in">max</span>(ans,dp[<span class="hljs-number">1</span>][n][s]);<span class="hljs-comment">//答案</span><br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dp学习笔记2——背包（作业表2总结）</title>
    <link href="/2024/01/12/dp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E8%83%8C%E5%8C%85%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%A1%A82%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <url>/2024/01/12/dp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94%E8%83%8C%E5%8C%85%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%A1%A82%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>主要是针对于背包问题的 dp 总结。</p><h1 id="背包">0/1 背包</h1><p>有 <span class="math inline">\(n\)</span> 个物品，有两个属性：容积<span class="math inline">\(w_i\)</span> 和价值 <spanclass="math inline">\(v_i\)</span>，要放入一个大小为 <spanclass="math inline">\(W\)</span> 的容器，问最大价值。</p><p>设 <span class="math inline">\(dp_{i,j}\)</span> 为装了前 <spanclass="math inline">\(i\)</span> 个物品后总体积为 <spanclass="math inline">\(j\)</span> 的最大价值。那么原来是 <spanclass="math inline">\(dp_{i-1,j-v_i}\)</span>，选了这个物品后体积增加，变成了 <spanclass="math inline">\(dp_{i-1+1,j-v_i+v_i} =dp_{i,j}\)</span>，或者不选于是就有 dp 方程：</p><p><span class="math display">\[dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j-v_i})\]</span></p><p>我们发现第一维只用到了 <span class="math inline">\(i\)</span> 和<spanclass="math inline">\(i-1\)</span>，我们就可以将第一维交替滚动或者原地的滚动，简化为：</p><p><spanclass="math display">\[dp_{now,j}=\max(dp_{last,j},dp_{last,j-v_i})\]</span></p><p>或</p><p><span class="math display">\[dp_j=\max(dp_j,dp_{j-v_i})\]</span></p><p>总体复杂度 <span class="math inline">\(O(nW)\)</span>。</p><h1 id="完全背包">完全背包</h1><p>跟 0/1 背包很想，只不过可以选很多次，我们对 dp 公式稍加更改就行：</p><p><span class="math display">\[dp_{i,j}= \max(dp_{i-1,j},dp_{i-1,j-v_i\times c}+w_i \times c)(0 \le c \le \infty)\]</span></p><p>滚动也很简单，考虑顺序就行。</p><p>总体复杂度 <span class="math inline">\(O(nW)\)</span>。</p><h1 id="多重背包">多重背包</h1><p>前面两者的结合体，每个物品后 <span class="math inline">\(c_i\)</span>个，有以下三种方法：</p><h2 id="暴力">暴力</h2><p>将其每一个物品按照 0/1 背包考虑，总体复杂度 <spanclass="math inline">\(O(\sum c_iW)\)</span>。</p><h2 id="二进制分组">二进制分组</h2><p>我们发现将 <span class="math inline">\(c_i\)</span> 化成几个形如<span class="math inline">\(2^k\)</span> 的和的形式，最后也能够组合成<span class="math inline">\(0\)</span> 到 <spanclass="math inline">\(c_i\)</span> 的数，所以我们可以将每个 <spanclass="math inline">\(c_i\)</span> 分解，再 0/1 背包 dp。</p><p>时间复杂度为 <span class="math inline">\(O(\sum \log c_iW)\)</span>。</p><h2 id="单调队列">单调队列</h2><p>我们来看，每一次转移，我们都是使用如下 dp 方程：</p><p><span class="math display">\[dp_{i,j}=\max(dp_{i-1,j},dp_{i-1,j-v_ic}+w_ic)(0 \le c \le c_i)\]</span></p><p>我们不妨将 <span class="math inline">\(j\)</span> 记为 <spanclass="math inline">\(pv_i+d\)</span>，而它在每一次转移中，都是转移的<span class="math inline">\(j- v_ic\)</span>，那么这个转移的数对 <spanclass="math inline">\(v_i\)</span> 满足 <spanclass="math inline">\((j-v_ic) \equiv (pv_i+d-cv_i) \equiv d(\bmod\v_i)\)</span>。</p><p>有了这个性质，我们可以枚举他的余数，然后每次依次加 <spanclass="math inline">\(v\)</span>来枚举要更新的，然后发现他能够更新到的区间只有那么一部分（依托于 <spanclass="math inline">\(c_i\)</span>），而且是一个连续的，有增有减的操作，我们就可以用单调队列来进行优化最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    cin &gt;&gt; v &gt;&gt; w &gt;&gt; c;<br>    c = <span class="hljs-built_in">min</span>(c, m / v);<br>    <span class="hljs-keyword">for</span> (ll k = <span class="hljs-number">0</span>; k &lt; v; k++)<br>    &#123;<br>        ll head = <span class="hljs-number">1</span>, tail = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">0</span>; j &lt;= (m - k) / v; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (head &lt;= tail &amp;&amp; j - c &gt; q[head])<br>            &#123;<br>                head++;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (head &lt;= tail &amp;&amp; dp[k + j * v] - j * w &gt;= last_dp[tail] - q[tail] * w)<br>            &#123;<br>                tail--;<br>            &#125;<br>            q[++tail] = j;<br>            last_dp[tail] = dp[k + j * v];<br>            dp[k + j * v] = last_dp[head] + ((j - q[head])) * w;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dp学习笔记1——LCS &amp; LIS（作业表1总结）</title>
    <link href="/2024/01/12/dp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94LIS-LCS%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%A1%A81%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <url>/2024/01/12/dp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94LIS-LCS%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%A1%A81%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="lis">LIS</h1><p>全名最长上升子序列。</p><h2 id="做法一">做法一</h2><p>设 <span class="math inline">\(dp_i\)</span> 为字符串 <spanclass="math inline">\(a\)</span> 中以 <spanclass="math inline">\(a_i\)</span> 结尾的 LIS，当前的 <spanclass="math inline">\(dp_i\)</span> 肯定要从比他小的地方枚举，所以 dp方程可以简单推出来：</p><p><span class="math display">\[dp_i = \max (1,dp_j+1)\ (i &gt; j,a_i&gt; a_j)\]</span></p><p>枚举两维，时间复杂度 <spanclass="math inline">\(O(n^2)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (ll j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &gt; a[j])<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="做法二">做法二</h2><p>考虑修改做法一，我们发现上述 dp方程是一个<strong>二位偏序</strong>问题，所以考虑用树状数组来优化。每次去寻找比当前字符更小的最大<span class="math inline">\(dp\)</span> 值。</p><p>第二维用树状数组优化掉了，时间复杂度 <span class="math inline">\(O(n\log n)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    dp[i] = <span class="hljs-built_in">getmax</span>((ll)(a[i]) - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<span class="hljs-comment">//树状数组优化</span><br>    <span class="hljs-built_in">modify</span>(a[i], dp[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="做法三">做法三</h2><p>考虑另一种做法，设 <span class="math inline">\(dp_i\)</span> 为长度为<span class="math inline">\(i\)</span> 的 LIS中最后出现的最小的值，显然其具有单调性。对于 <spanclass="math inline">\(a\)</span>的每一个字符，我们可以二分找到比其大的第一个，然后用这个字符去更新。</p><p>有一个二分查找的过程，时间复杂度 <span class="math inline">\(O(n \logn)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    *<span class="hljs-built_in">upper_bound</span>(dp + <span class="hljs-number">1</span>, dp + n + <span class="hljs-number">1</span>, a[i]) = a[i];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="lcs">LCS</h1><p>全名最长公共子序列。</p><h2 id="做法一-1">做法一</h2><p>设 <span class="math inline">\(dp_{i,j}\)</span> 为两个串 <spanclass="math inline">\(a,b\)</span> 其中 <spanclass="math inline">\(a\)</span> 的前 <spanclass="math inline">\(i\)</span> 个字符串与 <spanclass="math inline">\(b\)</span> 的前 <spanclass="math inline">\(j\)</span>个字符串的最长上升子序列，要么相等或不相等，所以 dp 递推式就为：</p><p><span class="math display">\[dp_{i,j} = \begin{cases}   dp_{i-1,j-1} + 1\ (a_i = b_j)   \\   \max(dp_{i-1,j},dp_{i,j-1})\ (a_i  \neq b_j)\end{cases}\]</span></p><p>同样是枚举两维，时间复杂度 <spanclass="math inline">\(O(n^2)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    <span class="hljs-keyword">for</span> (ll j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == b[j])<br>        &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            dp[i][j] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="做法二-1">做法二</h2><p><span class="math inline">\(O(n \log n)\)</span> 做法：</p><p>我们考虑将其转化为 LIS 来做。</p><p>我们将串 <span class="math inline">\(a\)</span>里的每个元素按顺序依次编号，那么我们不妨假设其 LCS 为 <spanclass="math inline">\(c\)</span>。那么 <spanclass="math inline">\(c\)</span> 的元素按照编号重新计算就是一个IS，那么我们将 <span class="math inline">\(b\)</span>的元素重新编号，找到其中的 IS，它在 <spanclass="math inline">\(a\)</span> 中也必定存在一个 IS与之对应且是其转换后的字符为之前的CS。所以我们只需要将其离散化重新编号后在 <spanclass="math inline">\(b\)</span> 串里找其 LIS 即可求出答案。</p><p>时间复杂度同 LIS 做法二或三，<span class="math inline">\(O(n \logn)\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    cin &gt;&gt; x;<br>    d[x] = i;<br>&#125;<br><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>&#123;<br>    cin &gt;&gt; x;<br>    last[d[x]] = i;<br>&#125;<br>last[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-comment">//离散化</span><br><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    dp[i] = <span class="hljs-number">1e17</span>;<br>&#125;<span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>    <span class="hljs-keyword">if</span> (last[i])<br>    &#123;<br>        *<span class="hljs-built_in">upper_bound</span>(dp + <span class="hljs-number">1</span>, dp + n + <span class="hljs-number">1</span>, last[i]) = last[i];<br>    &#125;<br>&#125;<span class="hljs-comment">//LIS 做法三</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024.1.6 本部月考总结</title>
    <link href="/2024/01/07/2024-1-6-%E6%9C%AC%E9%83%A8%E6%9C%88%E8%80%83%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/07/2024-1-6-%E6%9C%AC%E9%83%A8%E6%9C%88%E8%80%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>考的不好。</p><h1 id="a-过关斩将">A 过关斩将</h1><p><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=2661&amp;tid=A">LinkNKOJ</a></p><p>学了快一个月最短路，见到这种裸的分层图题，轻松就切了。</p><p>具体思路：Dijkstra 跑分层图，根据弱点类型来看更新哪一层。</p><h2 id="ac-code">AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll M=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>ll x,y,z;<br>ll next;<br>&#125; e[M&lt;&lt;<span class="hljs-number">1</span>];<br>ll elast[N];<br>ll tot=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll x,ll y,ll z)</span> </span>&#123;<br>tot++;<br>e[tot].x=x;<br>e[tot].y=y;<br>e[tot].z=z;<br>e[tot].next=elast[x];<br>elast[x]=tot;<br>&#125;<br>ll T;<br>ll n,m;<br>string op;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>ll x;<br>ll dis;<br>ll opt;<br><span class="hljs-built_in">node</span>(ll x=<span class="hljs-number">0</span>,ll dis=<span class="hljs-number">0</span>,ll opt=<span class="hljs-number">0</span>):<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">dis</span>(dis),<span class="hljs-built_in">opt</span>(opt) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(node a,node b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a.dis&gt;b.dis;<br>&#125;<br>&#125;;<br>ll dis[N][<span class="hljs-number">3</span>];<br><span class="hljs-type">bool</span> vis[N][<span class="hljs-number">3</span>];<br>ll s,t,xx;<br><span class="hljs-function">ll <span class="hljs-title">types</span><span class="hljs-params">(<span class="hljs-type">char</span> a)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;M&#x27;</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;L&#x27;</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;R&#x27;</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br>ll ans=<span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(ll st)</span> </span>&#123;<br>priority_queue&lt;node,vector&lt;node&gt;,cmp&gt;q;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">2</span>; j++) &#123;<br>dis[i][j]=<span class="hljs-number">1e17</span>;<br>vis[i][j]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>ll trp=<span class="hljs-built_in">types</span>(op[st<span class="hljs-number">-1</span>]);<br><span class="hljs-keyword">if</span>(!trp) &#123;<br>dis[st][<span class="hljs-number">1</span>]=dis[st][<span class="hljs-number">2</span>]=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(st,dis[st][<span class="hljs-number">1</span>],<span class="hljs-number">1</span>));<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(st,dis[st][<span class="hljs-number">2</span>],<span class="hljs-number">2</span>));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dis[st][trp]=<span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(st,dis[st][trp],trp));<br>&#125;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) &#123;<br>ll x=q.<span class="hljs-built_in">top</span>().x,opter=q.<span class="hljs-built_in">top</span>().opt;<br><span class="hljs-keyword">if</span>(x==t) &#123;<br>ans=q.<span class="hljs-built_in">top</span>().dis;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(vis[x][opter]) &#123;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>vis[x][opter]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(ll i=elast[x]; i; i=e[i].next) &#123;<br>ll y=e[i].y,opty=<span class="hljs-built_in">types</span>(op[y<span class="hljs-number">-1</span>]);<br><span class="hljs-keyword">if</span>(!opty) &#123;<br><span class="hljs-keyword">if</span>(dis[y][opter]&gt;dis[x][opter]+e[i].z) &#123;<br>dis[y][opter]=dis[x][opter]+e[i].z;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(y,dis[y][opter],opter));<br>&#125;<br>ll ropt;<br><span class="hljs-keyword">if</span>(opter==<span class="hljs-number">2</span>) &#123;<br>ropt=<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ropt=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(dis[y][ropt]&gt;dis[x][opter]+e[i].z+xx) &#123;<br>dis[y][ropt]=dis[x][opter]+e[i].z+xx;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(y,dis[y][ropt],ropt));<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(opty==opter) &#123;<br><span class="hljs-keyword">if</span>(dis[y][opter]&gt;dis[x][opter]+e[i].z) &#123;<br>dis[y][opter]=dis[x][opter]+e[i].z;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(y,dis[y][opter],opter));<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span>(dis[y][opty]&gt;dis[x][opter]+e[i].z+xx) &#123;<br>dis[y][opty]=dis[x][opter]+e[i].z+xx;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">node</span>(y,dis[y][opty],opty));<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--) &#123;<br><span class="hljs-built_in">memset</span>(elast,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(elast));<br>tot=<span class="hljs-number">0</span>;<br>ans=<span class="hljs-number">-1</span>;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t&gt;&gt;xx;<br>cin&gt;&gt;op;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br>ll x,y,z;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br><span class="hljs-built_in">add</span>(x,y,z);<br><span class="hljs-built_in">add</span>(y,x,z);<br>&#125;<br><span class="hljs-built_in">dijkstra</span>(s);<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="b-翻转游戏">B 翻转游戏</h1><p><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=2661&amp;tid=B">LinkNKOJ</a></p><p>赛上有想出来接近正解的思路，但是被我 <del>IQ=0</del>的大脑否决了（也告诉我们做事要有决心）。</p><p>思路：当 <span class="math inline">\(k\)</span>为偶数是，显然是没有答案的（消除总和为 <span class="math inline">\(S_n =2^n - 1\)</span>），当 <span class="math inline">\(k\)</span>是奇数时，消除的次数就为 <span class="math inline">\(T = \lceil\log_2{n} \rceil\)</span>，我们记录当前<strong>从第 <spanclass="math inline">\(T\)</span> 次开始</strong>的消除次数为 <spanclass="math inline">\(t\)</span>，只包含 <spanclass="math inline">\(1\)</span> 的区间左右端点为 <spanclass="math inline">\([l,r]\)</span>。当 <spanclass="math inline">\(2^{T - t + 1} \leq r - l + 1\)</span>时，我们就可以直接消掉这个区间的一部分，我们就以左端点 <spanclass="math inline">\(l\)</span> 为起点去消掉一部分 <spanclass="math inline">\(1\)</span>；否则我们不仅要消完整个区间，还要将外面的一些<span class="math inline">\(0\)</span> 给化成 <spanclass="math inline">\(1\)</span>，为了不受 <spanclass="math inline">\(r\)</span> 端点后面可能没有 <spanclass="math inline">\(0\)</span>，我们就从右端点 <spanclass="math inline">\(r\)</span> 来开始消除。最后再将新的 <spanclass="math inline">\([l,r]\)</span> 更新出来，继续这个过程。</p><h2 id="ac-code-1">AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll x,ll n)</span> </span>&#123;<br>ll ans=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n) &#123;<br><span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) &#123;<br>ans*=x;<br>&#125;<br>n&gt;&gt;=<span class="hljs-number">1</span>;<br>x*=x;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">getlog</span><span class="hljs-params">(ll x)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>ll l=<span class="hljs-number">1</span>,r=<span class="hljs-number">35</span>,mid;<br><span class="hljs-keyword">while</span>(l&lt;=r) &#123;<br>mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,mid)&lt;=x) &#123;<br>l=mid+<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r=mid<span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> l<span class="hljs-number">-1</span>;<br>&#125;<br>ll T;<br>ll n,k;<br>ll ans[<span class="hljs-number">1145</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;T;<br><span class="hljs-keyword">while</span>(T--) &#123;<br>cin&gt;&gt;n&gt;&gt;k;<br><span class="hljs-keyword">if</span>(k==<span class="hljs-number">0</span>) &#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl&lt;&lt;<span class="hljs-number">0</span>&lt;&lt;endl;;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(k%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>) &#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) &#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>ll l=<span class="hljs-number">1</span>,r=k;<br>ll times=<span class="hljs-built_in">getlog</span>(k)+(<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,<span class="hljs-built_in">getlog</span>(k))!=k);<br>ll rtime=times;<br>cout&lt;&lt;times&lt;&lt;endl;<br><span class="hljs-keyword">while</span>(times--) &#123;<br><span class="hljs-keyword">if</span>(r-l+<span class="hljs-number">1</span>&gt;=<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,times)) &#123;<br>ans[times]=l;<br>l+=<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,times);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ans[times]=r-<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,times)+<span class="hljs-number">1</span>;<br>ll befl=l;<br>l=r-<span class="hljs-built_in">qpow</span>(<span class="hljs-number">2</span>,times)+<span class="hljs-number">1</span>;<br>r=befl<span class="hljs-number">-1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">0</span>; i&lt;rtime; i++) &#123;<br>cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="c-大模法师">C 大模法师</h1><p><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=2661&amp;tid=C">LinkNKOJ</a></p><p>考场上想正解想不出来，就开始乱搞，结果正解居然也是乱搞。</p><p>思路：有很多乱搞思路能过，这里介绍一种。</p><p>我们随机从 <span class="math inline">\(a\)</span>序列里找两个<strong>不相等</strong>的数，记作 <spanclass="math inline">\(a_l\)</span> 和 <spanclass="math inline">\(a_r\)</span>，假设这两个数对于序列中某个数同余，我们不妨对两个数换一种方式记录，记<span class="math inline">\(a_l = l&#39;x + y\)</span>，<spanclass="math inline">\(a_r = r&#39;x + y\)</span>，则两数之差就为 <spanclass="math inline">\((l&#39; - r&#39;)x\)</span>，也就是等于 <spanclass="math inline">\(a_l - a_r\)</span>。我们就可以枚举这个 <spanclass="math inline">\(x\)</span>，当 <span class="math inline">\((a_l -a_r) \equiv 0\  (\bmod x)\)</span> 时，就说明 <spanclass="math inline">\(x\)</span> <strong>可能满足</strong>要求，我们再用<span class="math inline">\(O(n)\)</span>的时间去检查，如果是就更新答案。设进行了 <spanclass="math inline">\(T\)</span> 此操作，复杂度约为 <spanclass="math inline">\(O(Tn\sqrt{n})\)</span>，当然跑不满，加点优化就可以很快过掉。</p><h2 id="ac-code-2">AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll M=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>ll vis[M];<br>ll n;<br>ll a[N];<br><span class="hljs-function">mt19937 <span class="hljs-title">rnd</span><span class="hljs-params">(time(<span class="hljs-literal">NULL</span>))</span></span>;<br>vector&lt;ll&gt;botton;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>botton.<span class="hljs-built_in">resize</span>(<span class="hljs-number">100010</span>);<br>cin&gt;&gt;n;<br>ll rmax=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;a[i];<br>botton[a[i]%<span class="hljs-number">100000</span>]++;<br>rmax=<span class="hljs-built_in">max</span>(rmax,botton[a[i]%<span class="hljs-number">100000</span>]);<br>&#125;<br><span class="hljs-keyword">if</span>(rmax&gt;=(n/<span class="hljs-number">2</span>+(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>))) &#123;<br>cout&lt;&lt;<span class="hljs-number">100000</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>ll ans=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(ll oo=<span class="hljs-number">1</span>; oo&lt;=<span class="hljs-number">500</span>; oo++) &#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">clock</span>()&gt;=<span class="hljs-number">1200</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>ll x=a[<span class="hljs-built_in">rnd</span>()%n+<span class="hljs-number">1</span>];<br>ll y=a[<span class="hljs-built_in">rnd</span>()%n+<span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span>(x==y) &#123;<br>oo--;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br>ll sums=<span class="hljs-built_in">abs</span>(x-y);<br><span class="hljs-keyword">for</span>(ll j=sums; j&gt;=<span class="hljs-number">1</span>; j--) &#123;<br><span class="hljs-keyword">if</span>(j&lt;=ans) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(sums%j==<span class="hljs-number">0</span>&amp;&amp;!vis[j]) &#123;<br><span class="hljs-keyword">for</span>(ll k=<span class="hljs-number">0</span>; k&lt;j; k++) &#123;<br>botton[k]=<span class="hljs-number">0</span>;<br>&#125;<br>ll maxx=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(ll k=<span class="hljs-number">1</span>; k&lt;=n; k++) &#123;<br>botton[a[k]%j]++;<br>maxx=<span class="hljs-built_in">max</span>(botton[a[k]%j],maxx);<br><span class="hljs-keyword">if</span>(maxx&gt;=(n/<span class="hljs-number">2</span>+(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>))) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(maxx&gt;=(n/<span class="hljs-number">2</span>+(n%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>))) &#123;<br>ans=<span class="hljs-built_in">max</span>(ans,j);<br>vis[j]=<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>vis[j]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(ll i=j*<span class="hljs-number">2</span>; i&lt;M; i+=j) &#123;<br>vis[i]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><del>这种抽象的题写不出正解也可以去乱搞一下，说不定就过了</del>。</p><h1 id="d-彩色的树">D 彩色的树</h1><p><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=2661&amp;tid=D">LinkNKOJ</a></p><p>没怎么听懂，好像就是用 DFS 来考虑每个颜色的贡献。</p><h2 id="ac-code-3">AC code</h2><p><del>还没 AC 怎么可能有 AC code</del></p><h1 id="后记">后记</h1><p>要期末考试了，压力还是有点大，希望自己还是能够坚持下来，思维多练练，代码多敲点，套路多见见（最近也见了很多），希望考试和后面的时候能发挥出来。</p>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论学习笔记1——最短路（作业表4总结）</title>
    <link href="/2023/12/30/%E5%9B%BE%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%A1%A84%E6%80%BB%E7%BB%93%EF%BC%89/"/>
    <url>/2023/12/30/%E5%9B%BE%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%A1%A84%E6%80%BB%E7%BB%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="算法">算法</h1><h2 id="floyd-warshall">Floyd-Warshall</h2><p>求全源最短路径。</p><span id="more"></span><p>流程：</p><p>设 <span class="math inline">\(dp_{k,i,j}\)</span> 为经过 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(k\)</span> 点的 <spanclass="math inline">\(i,j\)</span>之间的最短路，每次转移找一个新的未被转移过的点转移，则有以下转移方程：</p><p><span class="math display">\[dp_{k,i,j} = dp_{k-1,i,k} +dp_{k-1,k,j}\]</span></p><p>可以滚动掉一维，设 <span class="math inline">\(dp_{i,j}\)</span> 为<span class="math inline">\(i,j\)</span> 之间的最短路，于是就有：</p><p><span class="math display">\[dp_{i,j} = \min \limits_{1 \le k \le n}\{dp_{i,k} + dp_{k,j}\}\]</span></p><p><strong>注意：顺序为 <spanclass="math inline">\(k,i,j\)</span>，顺序可调换，循环 <spanclass="math inline">\(6\)</span> 次也能得出答案。</strong></p><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="dijkstra">Dijkstra</h2><p>求单源最短路径。</p><p>本质：贪心+BFS+DP。</p><p>流程：</p><p>设起点为 <span class="math inline">\(s\)</span>，令 <spanclass="math inline">\(dis_i = +\infty(i \in n)\)</span>，并将 <spanclass="math inline">\(dis_s\)</span> 设为 <spanclass="math inline">\(0\)</span>。</p><p>每一次，寻找 <span class="math inline">\(n\)</span> 个点中 <spanclass="math inline">\(dis_i\)</span>的最小值，并用这个最小值去更新它周围的边。</p><p>正确性证明：在正权图中，以当前权值最小的点去更新其他点，令有一点去更新会更优而又不是权值最小的点，因为边权为正，他更新一个点所花的花费会大于一个更近且权值更小的点，所以应用权值更小的点去更新，矛盾，故得证。</p><p>时间复杂度 <span class="math inline">\(O(n^2)\)</span>（找最小点<span class="math inline">\(O(n)\)</span>，更新 <spanclass="math inline">\(n\)</span> 次 <spanclass="math inline">\(O(n)\)</span>）。</p><p>可以用优先队列来找 <span class="math inline">\(dis_i\)</span>的最小值，时间复杂度可以优化到 <span class="math inline">\(O(m \logm)\)</span>。</p><p><strong>注意：不能处理含有负权边的图。</strong></p><h2 id="bellman-ford">Bellman-Ford</h2><p>让起点 <span class="math inline">\(dis_s = 0\)</span>。对每个点进行<span class="math inline">\(n-1\)</span> 次松弛操作，可得到关于 <spanclass="math inline">\(s\)</span> 的单源最短路。</p><p>正确性证明：在图 <span class="math inline">\(G(V,E)\)</span>中，令一点 <span class="math inline">\(v \neq s\)</span> ，则到达 <spanclass="math inline">\(v\)</span> 的最短路至多经过 <spanclass="math inline">\(n-1\)</span> 个点，亦能通过 <spanclass="math inline">\(n-1\)</span> 次松弛（递推更新）去更新到点 <spanclass="math inline">\(v\)</span>，得证。</p><p>时间复杂度 <span class="math inline">\(O(nm)\)</span>。</p><p><strong>注意：可以处理含有负权边的图，且可以找负环。</strong></p><h2 id="spfa">SPFA</h2><p>是 Bellman-Ford 算法的优化。</p><p>由于每次松弛操作都会有很多的<strong>不必要</strong>的边被松弛，于是我们可以只松弛<strong>那些被松驰过了的点</strong>的边。</p><p>期望复杂度约为 <span class="math inline">\(O(kE)\)</span>，其中 <spanclass="math inline">\(k\)</span>是一个常数，但<strong>最坏</strong>复杂度为 <spanclass="math inline">\(O(nm)\)</span>（也就是退化为 Bellman-Ford算法）。</p><h1 id="例题">例题</h1><h2 id="c-usaco4.1.3fence-loops篱笆回路">C 【USACO4.1.3】FenceLoops篱笆回路</h2><p><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=2627&amp;tid=C">LinkNKOJ</a> and <a href="https://www.luogu.com.cn/problem/P2738">LinkLuogu</a></p><p>这个题要求最小环，首先将点给离散化出来。要找最小环，因为数据范围很小，考虑Floyd-Warshall 算法，我们不妨正好在枚举 <spanclass="math inline">\(k\)</span> 的时候，因为 <spanclass="math inline">\(dp_{i,j}\)</span> 没有更新，所以当前的 <spanclass="math inline">\(dp_{i,k}+dp_{k,j}\)</span> 的路线肯定不会是 <spanclass="math inline">\(dp_{i,j}\)</span> 的路线（如下图），所以我们可以用<span class="math inline">\(dp_{i,j}+dp_{i,k}+dp_{k,j}\)</span>去更新最小环长度。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/xrjvuou0.png" /></p><p><a href="https://www.luogu.com.cn/record/139791257">AC code</a></p><h2 id="w-最短路">W 最短路</h2><p><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=2627&amp;tid=C">LinkNKOJ</a> and <ahref="https://codeforces.com/problemset/problem/1163/F">LinkCodeforces</a> anf <ahref="https://www.luogu.com.cn/problem/CF1163F">Link Luogu</a></p><p>本题求的是在正权图 <span class="math inline">\(G(V,E)\)</span>中，选择一条边并更新他的边权，并对于每个询问求其修改后 <spanclass="math inline">\(1 \to n\)</span> 的最短路。</p><p>不妨分类讨论：</p><ol type="1"><li>当这条被修改的边不在最短路上时，修改后的答案要么是原先的最短路，要么是从起点或终点到这条边的一端再从另一端出来的路径长度，因为如果我们考虑不经过这条边的路径长度，它们肯定是比原先求出的最短路要大，然后就只能考虑经过这条边。经过这条边显然最短的路径长度就是两端点到起点和终点的距离加上这条边自身的边权（如下图）。</li></ol><p><imgsrc="https://cdn.luogu.com.cn/upload/image_hosting/082xn1j8.png" /></p><ol start="2" type="1"><li><p>如果这条边本身就在最短路上：</p><ol type="1"><li>这条边比原来的边要短，那肯定最短路就是原来的最短路减去这条边现在比以前短的长度。</li><li>这条边比原来的边要长，这个有点难考虑，我会从以下方面说明：</li></ol><ul><li>引理一：在正权图 <span class="math inline">\(G(V,E)\)</span>中最短路一定是一条链。</li></ul><p>证明：最短路因为要保证最短性，且图是正权图，不可能有 <spanclass="math inline">\(0\)</span>环或负环，所以在最短路上一定不可能有环，得证。</p><ul><li>引理二：在正权图 <span class="math inline">\(G(V,E)\)</span>中，从起点 <span class="math inline">\(s\)</span> 出发，到达点 <spanclass="math inline">\(t\)</span>，则路径 <span class="math inline">\(s\to t\)</span> <strong>用 dijkstra 算法找到的最短路</strong>必与其他从<span class="math inline">\(s\)</span> 出发的路径共享一段前缀。</li></ul><p>证明：假设这条<strong>最短</strong>路径它的共享的前缀中间有间隔，且产生作用与原最短路相等。由于中间间隔的部分又回到了最短路上，所以更新后面的点就无须考虑。而且由于dijkstra 算法的特性，这种两条相等的最短路的终点 <spanclass="math inline">\(v\)</span>只会访问一次，而假设的情况确是两次，矛盾，得证。</p><ul><li>引理三：令集合 <span class="math inline">\(S\)</span>为最短路上的点的点集，则含有两个点的点集 <spanclass="math inline">\(S&#39; = \{u,v\}\)</span> 满足 <spanclass="math inline">\(S \cap S&#39; = \varnothing\)</span>，满足在 <spanclass="math inline">\(1 \to u\)</span>与最短路的前缀在最短路上的最后一个点和 <span class="math inline">\(v \ton\)</span>与最短路的后缀在最短路上的最后一个点中间的最短路上的边任删一条而它的删边最短路为<span class="math inline">\(dis_{1 \to u} + dis_{u \to v} + dis_{v \ton}\)</span>，如果有多个就取最小值。</li></ul><p>证明：由引理二得，假设在最短路上的最后一个前缀和最后一个后缀的点分别记作<span class="math inline">\(x,y\)</span>。那么，假设有一条边 <spanclass="math inline">\((o,p)\)</span>删掉之后所根据引理三得出的答案是比正确答案更大的。那么一定有一条路径<span class="math inline">\(1 \to u_1 \to v_1 \to n\)</span>原来中间的最短路上的边并不经过 <spanclass="math inline">\((o,p)\)</span>但是有另一条路径使其从该路径中脱离出来并回到最短路时中间是有 <spanclass="math inline">\((o,p)\)</span>边的，并且答案肯定是最小的，那么这条路径肯定存在一条边，满足其与最短路上的前缀和后缀中间必经过<spanclass="math inline">\((o,p)\)</span>，而后用其去更新答案一定比之前更优，而与之前的假设相悖，得证。</p><ul><li>引理四：引理三中所设的 <span class="math inline">\(\{u,v\}\)</span>可以在一条边上而引理三依旧成立。</li></ul><p>证明：可以用引理三的证明过程来证明。</p></li></ol><p>所以，综上所述，利用引理四，我们可以枚举每一条<strong>不在最短路上</strong>的边。然后因为其两点前后缀在同一最短路上且连续，我们可以给每条边编上号，用数据结构来维护其删掉这条边后路径长度的最小值。</p><p><ahref="https://codeforces.com/problemset/submission/1163/240331475">ACcode</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P3736 [HAOI2016] 字符合并 题解</title>
    <link href="/2023/11/25/Luogu-P3736-HAOI2016-%E5%AD%97%E7%AC%A6%E5%90%88%E5%B9%B6-%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/11/25/Luogu-P3736-HAOI2016-%E5%AD%97%E7%AC%A6%E5%90%88%E5%B9%B6-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="传送门">传送门</h1><p><a href="https://www.luogu.com.cn/problem/P3736">传送门</a></p><h1 id="思路">思路</h1><p>题目要求一段数<strong>合并</strong>后的最大分数，看到合并，且 <spanclass="math inline">\(n\)</span> 的范围才 <spanclass="math inline">\(300\)</span>，自然的想到复杂度 <spanclass="math inline">\(O(n^3)\)</span> 的区间 dp。</p><p>注意到 <span class="math inline">\(k\)</span>的范围很小，我们就可以想到复杂度为 <spanclass="math inline">\(O(2^k)\)</span> 状压，状压字符当前的状态。</p><span id="more"></span><p>结合起来，<span class="math inline">\(dp_{i,j,s}\)</span> 表示区间<code>[i,j]</code> 合并后状态为 <spanclass="math inline">\(s\)</span>，有 <span class="math inline">\(O(n^32^k)\)</span> 的暴力，显然易见会超时，这时我们就要找合并的性质。</p><p>不妨假设一段长度为 <span class="math inline">\(t\)</span> 的<code>01</code> 序列，显然易见，当 <span class="math inline">\(t =k\)</span> 时，合并次数为 <span class="math inline">\(1\)</span>。</p><p>假设合并完一次后，得到的长度为 <spanclass="math inline">\(1\)</span>，如果再想合并一次，就要让合并完后的长度<span class="math inline">\(1\)</span> 加上另一端区间的长度 <spanclass="math inline">\(t_1\)</span> 的和为 <spanclass="math inline">\(k\)</span>，那显然 <span class="math inline">\(t_1= k-1\)</span>。合并后的长度为 <spanclass="math inline">\(1\)</span>。</p><p>然后，再合并一次，那么 <span class="math inline">\(t_2 =k-1\)</span>。合并后的长度仍为 <spanclass="math inline">\(1\)</span>。</p><p>显然，如果继续合并，那么会有无数个 <spanclass="math inline">\(k-1\)</span> 被合并，那么就有 <spanclass="math inline">\(t_n = k-1\)</span>，那么能够合并为长度为 <spanclass="math inline">\(1\)</span> 的区间的原长度就为 <spanclass="math inline">\(\sum \limits_{i = 1}^{n}{t_i}+1 \to n(k-1) +1\)</span>。</p><p>扩展一下，如果一个字符串长度为 <spanclass="math inline">\(l_1\)</span>，合并后的长度为 <spanclass="math inline">\(l_2\)</span>，那么根据上述方程，就有合并后的长度<span class="math inline">\(l_2 = (l_1 - 1) \bmod (k-1) +1\)</span>，于是枚举 <span class="math inline">\(l\)</span>的时候就不用每个都枚举，每次从右往左依次减去 <spanclass="math inline">\(k-1\)</span>。</p><p>所以显然易见 dp 方程就为：</p><p><span class="math display">\[\begin{cases}  dp_{i,j,2s} = \max \limits_{i \le l &lt; j,(j - 1 - l)\bmod( k - 1) =0} \{ dp_{i,l,s} + dp_{l+1,j,0} \} \\  dp_{i,j,(2s) \vee 1} = \max \limits_{i \le l &lt; j,(j - 1 - l)\bmod(k - 1) = 0} \{ dp_{i,l,s} + dp_{l+1,j,1} \}\end{cases}\]</span></p><p>特别的，当一段区间合并后的长度为 <spanclass="math inline">\(1\)</span>时，可以将所有的状态合并为一个字符，也就是：</p><p><span class="math display">\[\begin{cases}  dp_{i,j,0} = \max \limits_{0 \le s \le 2^k-1,r_s =0}\{dp_{i,j,s}+w_s\} \\  dp_{i,j,1} = \max \limits_{0 \le s \le 2^k-1,r_s =1}\{dp_{i,j,s}+w_s\}\end{cases}\]</span></p><p>这里的 <span class="math inline">\(r_s\)</span> 表示状态为 <spanclass="math inline">\(s\)</span> 的字符串合并后的答案，<spanclass="math inline">\(w_s\)</span>表示合并得到的分数，注意要开辅助数组储存。</p><h1 id="ac-code">AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">310</span>;<br><span class="hljs-type">const</span> ll K=<span class="hljs-number">7</span>;<br><span class="hljs-type">bool</span> sum[N];<br><span class="hljs-function">ll <span class="hljs-title">getsum</span><span class="hljs-params">(ll i,ll j)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(i&gt;j)<span class="hljs-built_in">swap</span>(i,j);<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll k=j,q=<span class="hljs-number">0</span>; k&gt;=i; k--,q++) &#123;<br>ans+=(sum[k])*(<span class="hljs-number">1</span>&lt;&lt;q);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">wes</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> ll x)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">32</span>-__builtin_clz(x);<br>&#125;<br><span class="hljs-comment">//调试 </span><br>ll n,kk;<br>ll dp[N][N][<span class="hljs-number">1</span>&lt;&lt;(K+<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>];<br>ll str[<span class="hljs-number">1</span>&lt;&lt;(K+<span class="hljs-number">1</span>)|<span class="hljs-number">1</span>];<br><span class="hljs-type">bool</span> tr[(<span class="hljs-number">1</span>&lt;&lt;(K+<span class="hljs-number">1</span>))|<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin&gt;&gt;n&gt;&gt;kk;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>; j&lt;=n; j++) &#123;<br><span class="hljs-keyword">for</span>(ll s=(<span class="hljs-number">1</span>&lt;&lt;kk)<span class="hljs-number">-1</span>; s&gt;=<span class="hljs-number">0</span>; s--) &#123;<br>dp[i][j][s]=<span class="hljs-number">-1145141919810ll</span>;<span class="hljs-comment">//初始化 </span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;sum[i];<br>dp[i][i][sum[i]]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=(<span class="hljs-number">1</span>&lt;&lt;kk); i++) &#123;<br>cin&gt;&gt;tr[i<span class="hljs-number">-1</span>]&gt;&gt;str[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span>(ll k=<span class="hljs-number">2</span>; k&lt;=n; k++) &#123;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n-k+<span class="hljs-number">1</span>; i++) &#123;<br>ll j=i+k<span class="hljs-number">-1</span>;<br>ll sizee=(k<span class="hljs-number">-1</span>)%(kk<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">if</span>(sizee==<span class="hljs-number">0</span>) &#123;<br>sizee=kk<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(ll l=j<span class="hljs-number">-1</span>; l&gt;=i; l-=(kk<span class="hljs-number">-1</span>)) &#123;<br><span class="hljs-keyword">for</span>(ll s=(<span class="hljs-number">1</span>&lt;&lt;(sizee))<span class="hljs-number">-1</span>; s&gt;=<span class="hljs-number">0</span>; s--) &#123;<br>dp[i][j][s&lt;&lt;<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][s&lt;&lt;<span class="hljs-number">1</span>],dp[i][l][s]+dp[l+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]);<br>dp[i][j][s&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][s&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>],dp[i][l][s]+dp[l+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(sizee==kk<span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">//合并后的长度为1</span><br>ll r[<span class="hljs-number">2</span>];<br>r[<span class="hljs-number">0</span>]=r[<span class="hljs-number">1</span>]=<span class="hljs-number">-1145141919810ll</span>;<br><span class="hljs-keyword">for</span>(ll s=(<span class="hljs-number">1</span>&lt;&lt;kk)<span class="hljs-number">-1</span>; s&gt;=<span class="hljs-number">0</span>; s--) &#123;<br>r[tr[s]]=<span class="hljs-built_in">max</span>(r[tr[s]],dp[i][j][s]+str[s]);<br>&#125;<br>dp[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">0</span>],r[<span class="hljs-number">0</span>]);<br>dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(dp[i][j][<span class="hljs-number">1</span>],r[<span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br>ll ans=<span class="hljs-number">-1145141919810ll</span>;<br><span class="hljs-keyword">for</span>(ll s=(<span class="hljs-number">1</span>&lt;&lt;kk)<span class="hljs-number">-1</span>; s&gt;=<span class="hljs-number">0</span>; s--) &#123;<br>ans=<span class="hljs-built_in">max</span>(ans,dp[<span class="hljs-number">1</span>][n][s]);<span class="hljs-comment">//答案</span><br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>解题题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces CF896C Willem, Chtholly and Seniorious 详解</title>
    <link href="/2023/11/05/Codeforces-CF896C-Willem-Chtholly-and-Seniorious-%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/11/05/Codeforces-CF896C-Willem-Chtholly-and-Seniorious-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>一道模板题。</p><p><a href="https://www.luogu.com.cn/problem/CF896C">传送门</a></p><span id="more"></span><h1 id="关于珂朵莉树">关于珂朵莉树</h1><h2 id="你需要知道以下内容">1.你需要知道以下内容</h2><ul><li>关于 <code>set</code> 的部分知识</li></ul><h2 id="什么是珂朵莉树">2.什么是珂朵莉树</h2><p>一种<strong>暴力</strong>数据结构，适用于随机生成的数据结构题以及<strong>骗分</strong>，主要有两种操作。</p><h2 id="初始化">3.初始化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>ll l,r;<span class="hljs-comment">//左、右端点</span><br><span class="hljs-keyword">mutable</span> ll v;<br><span class="hljs-built_in">node</span>(ll l,ll r=<span class="hljs-number">0</span>,ll v=<span class="hljs-number">0</span>):<span class="hljs-built_in">l</span>(l),<span class="hljs-built_in">r</span>(r),<span class="hljs-built_in">v</span>(v) &#123;&#125; <br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;a) <span class="hljs-type">const</span>&#123;<br><span class="hljs-keyword">return</span> l&lt;a.l; <span class="hljs-comment">//根据左端点进行排序</span><br>&#125; <br>&#125;; <br></code></pre></td></tr></table></figure><p>在这段代码中，我们用 <span class="math inline">\(l\)</span> 和 <spanclass="math inline">\(r\)</span> 变量储存当前区间的左端点和右端点。<spanclass="math inline">\(v\)</span> 是所需要储存的内容，注意到 <spanclass="math inline">\(v\)</span> 前有关键字<code>mutable</code>。意思是“可变的”，因为 <code>set</code> 中储存的<span class="math inline">\(v\)</span>是一个常量，如果不加这个关键字会报错<code>error:cannot assign to return value because function 'operator-&gt;' returns a const value</code>。</p><p>然后，我们用一个 <code>set</code>来进行维护，为了后面的操作，我们会根据左端点来进行排序。最终维护下来就是下图所展示的。</p><figure><img src="https://cdn.luogu.com.cn/upload/image_hosting/tx535itn.png"alt="odt1" /><figcaption aria-hidden="true">odt1</figcaption></figure><h2 id="split-操作">4. split 操作</h2><p>当一段区间需要被分开时，我们就需要 <code>split</code> 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;node&gt;::<span class="hljs-function">iterator <span class="hljs-title">split</span><span class="hljs-params">(ll pos)</span></span>&#123;<br>set&lt;node&gt;::iterator it=s.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">node</span>(pos));<br><span class="hljs-keyword">if</span>(it!=s.<span class="hljs-built_in">end</span>()&amp;&amp;(it-&gt;l)==pos)&#123;<br><span class="hljs-keyword">return</span> it;<br>&#125;<br>it--;<br>ll l=it-&gt;l,r=it-&gt;r,v=it-&gt;v;<br><span class="hljs-keyword">if</span>(r&lt;pos)<span class="hljs-keyword">return</span> s.<span class="hljs-built_in">end</span>();<br>s.<span class="hljs-built_in">erase</span>(it);<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(l,pos<span class="hljs-number">-1</span>,v));<br><span class="hljs-keyword">return</span> s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(pos,r,v)).first;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此前，我们对 <span class="math inline">\(l\)</span>端点进行了排序，所以我们就可以二分查找 <code>pos</code>所在的区间，再将这个区间分割为 <code>[l,pos-1]</code> 和<code>[pos,r]</code> 两个区间。如果说 <code>pos</code>正好在这段区间的开头的话，显然易见就不用分割了。</p><figure><img src="https://cdn.luogu.com.cn/upload/image_hosting/1ge627vx.png"alt="odt2" /><figcaption aria-hidden="true">odt2</figcaption></figure><h2 id="assign-操作">5. assign 操作</h2><p>当一段区间需要合并时，我们就需要 <code>assign</code> 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(ll l,ll r,ll v)</span></span>&#123;<br>set&lt;node&gt;::iterator itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>s.<span class="hljs-built_in">erase</span>(itl,itr);<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(l,r,v));<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个操作中，我们先将 <code>[l,r]</code>区间分割出来，<code>erase</code> 将 <code>[l,r]</code>区间都给清空了，然后再插入一段新的区间，值为 <spanclass="math inline">\(v\)</span>。</p><figure><img src="https://cdn.luogu.com.cn/upload/image_hosting/yj4gwn8t.png"alt="odt3" /><figcaption aria-hidden="true">odt3</figcaption></figure><h1 id="关于本题的分析">关于本题的分析</h1><h2 id="操作">1 操作</h2><p>将区间 <code>[l,r]</code> 的值全部增加 <spanclass="math inline">\(v\)</span>，只需要暴力将 <code>[l,r]</code>内所有的区间的值都增加 <span class="math inline">\(v\)</span>即可。（这也是为什么要有 <code>mutable</code> 的原因）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll l,ll r,ll x)</span> </span>&#123;<br>set&lt;node&gt;::iterator itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br><span class="hljs-keyword">for</span>(set&lt;node&gt;::iterator it=itl; it!=itr; it++) &#123;<br>(it-&gt;v)+=x;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="操作-1">2 操作</h2><p>就是 <code>assign</code> 操作。</p><h2 id="操作-2">3 操作</h2><p>将区间 <code>[l,r]</code> 内的所有区间的 <spanclass="math inline">\(v\)</span> 值排序，记录多少个，然后枚举到 <spanclass="math inline">\(x\)</span> 个为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node2</span> &#123;<span class="hljs-comment">//排序所用的结构体</span><br>ll v,cnt;<br><span class="hljs-built_in">node2</span>(ll v,ll cnt):<span class="hljs-built_in">v</span>(v),<span class="hljs-built_in">cnt</span>(cnt) &#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node2 a,node2 b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a.v&lt;b.v;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">search</span><span class="hljs-params">(ll l,ll r,ll x)</span> </span>&#123;<br>set&lt;node&gt;::iterator itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>vector&lt;node2&gt;v;<br><span class="hljs-keyword">for</span>(set&lt;node&gt;::iterator it=itl; it!=itr; it++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">node2</span>(it-&gt;v,(it-&gt;r)-(it-&gt;l)+<span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmp);<br>ll i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;v.<span class="hljs-built_in">size</span>(); i++) &#123;<span class="hljs-comment">//从小到大枚举</span><br><span class="hljs-keyword">if</span>(v[i].cnt&lt;x)x-=v[i].cnt;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> v[i].v;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="操作-3">4 操作</h2><p>答案就为区间 <code>[l,r]</code> 内所有区间的值的 <spanclass="math inline">\(x\)</span> 次方再乘上区间长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a_,ll n_,ll p_)</span> </span>&#123;<br>ll ans_=<span class="hljs-number">1</span>;<br>a_%=p_;<br><span class="hljs-keyword">while</span>(n_) &#123;<br><span class="hljs-keyword">if</span>(n_&amp;<span class="hljs-number">1</span>)ans_=ans_*a_%p_;<br>n_/=<span class="hljs-number">2</span>;<br>a_=a_*a_%p_;<br>&#125;<br><span class="hljs-keyword">return</span> ans_;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">getans_pow</span><span class="hljs-params">(ll l,ll r,ll x,ll y)</span> </span>&#123;<br>ll ans_=<span class="hljs-number">0</span>;<br>set&lt;node&gt;::iterator itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br><span class="hljs-keyword">for</span>(set&lt;node&gt;::iterator it=itl; it!=itr; it++) &#123;<br>ans_+=(<span class="hljs-built_in">qpow</span>(it-&gt;v,x,y)*(((it-&gt;r)-(it-&gt;l)+<span class="hljs-number">1</span>)%y))%y;<span class="hljs-comment">//区间长度乘区间值的 x 次方</span><br>ans_%=y;<br>&#125;<br><span class="hljs-keyword">return</span> ans_%y;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="注意点">注意点</h1><p>在分割区间时，要先分割右边，在分割左边，也就是先<code>split(r+1)</code>，再<code>split(l)</code>。不然顺序不对在分割时可能会找不到分割区间。</p><h1 id="ac-code">AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll unsigned long long</span><br><span class="hljs-type">const</span> ll P=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>ll n,m,seed,vmax;<br><span class="hljs-function">ll <span class="hljs-title">rnd</span><span class="hljs-params">()</span> </span>&#123;<br>ll seedd=seed;<br>seed=(seed*<span class="hljs-number">7</span>+<span class="hljs-number">13</span>)%P;<br><span class="hljs-keyword">return</span> seedd;<br>&#125;<br>ll a[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">question</span> &#123;<br>ll op,l,r,x,y;<br>&#125; q[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">random_</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>a[i]=(<span class="hljs-built_in">rnd</span>()%vmax)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br>q[i].op=(<span class="hljs-built_in">rnd</span>()%<span class="hljs-number">4</span>)+<span class="hljs-number">1</span>;<br>q[i].l=(<span class="hljs-built_in">rnd</span>()%n)+<span class="hljs-number">1</span>;<br>q[i].r=(<span class="hljs-built_in">rnd</span>()%n)+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(q[i].l&gt;q[i].r) &#123;<br><span class="hljs-built_in">swap</span>(q[i].l,q[i].r);<br>&#125;<br><span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">3</span>) &#123;<br>q[i].x=(<span class="hljs-built_in">rnd</span>()%(q[i].r-q[i].l+<span class="hljs-number">1</span>))+<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>q[i].x=(<span class="hljs-built_in">rnd</span>()%vmax)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">4</span>) &#123;<br>q[i].y=(<span class="hljs-built_in">rnd</span>()%vmax)+<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>ll l,r;<br><span class="hljs-keyword">mutable</span> ll v;<br><span class="hljs-built_in">node</span>(ll l,ll r=<span class="hljs-number">0</span>,ll v=<span class="hljs-number">0</span>):<span class="hljs-built_in">l</span>(l),<span class="hljs-built_in">r</span>(r),<span class="hljs-built_in">v</span>(v) &#123;&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;a) <span class="hljs-type">const</span> &#123;<br><span class="hljs-keyword">return</span> l&lt;a.l;<br>&#125;<br>&#125;;<br>set&lt;node&gt;s;<br>set&lt;node&gt;::<span class="hljs-function">iterator <span class="hljs-title">split</span><span class="hljs-params">(ll pos)</span> </span>&#123;<br>set&lt;node&gt;::iterator it=s.<span class="hljs-built_in">lower_bound</span>(<span class="hljs-built_in">node</span>(pos));;<br><span class="hljs-keyword">if</span>(it!=s.<span class="hljs-built_in">end</span>()&amp;&amp;(it-&gt;l)==pos) &#123;<br><span class="hljs-keyword">return</span> it;<br>&#125;<br>it--;<br>ll l=it-&gt;l,r=it-&gt;r,v=it-&gt;v;<br><span class="hljs-keyword">if</span>(r&lt;pos)<span class="hljs-keyword">return</span> s.<span class="hljs-built_in">end</span>();<br>s.<span class="hljs-built_in">erase</span>(it);<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(l,pos<span class="hljs-number">-1</span>,v));<br><span class="hljs-keyword">return</span> s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(pos,r,v)).first;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(ll l,ll r,ll x)</span> </span>&#123;<br>set&lt;node&gt;::iterator itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);;<br>s.<span class="hljs-built_in">erase</span>(itl,itr);<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(l,r,x));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll l,ll r,ll x)</span> </span>&#123;<br>set&lt;node&gt;::iterator itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br><span class="hljs-keyword">for</span>(set&lt;node&gt;::iterator it=itl; it!=itr; it++) &#123;<br>(it-&gt;v)+=x;<br>&#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node2</span> &#123;<br>ll v,cnt;<br><span class="hljs-built_in">node2</span>(ll v,ll cnt):<span class="hljs-built_in">v</span>(v),<span class="hljs-built_in">cnt</span>(cnt) &#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node2 a,node2 b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a.v&lt;b.v;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">search</span><span class="hljs-params">(ll l,ll r,ll x)</span> </span>&#123;<br>set&lt;node&gt;::iterator itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br>vector&lt;node2&gt;v;<br><span class="hljs-keyword">for</span>(set&lt;node&gt;::iterator it=itl; it!=itr; it++) &#123;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">node2</span>(it-&gt;v,(it-&gt;r)-(it-&gt;l)+<span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),cmp);<br>ll i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;v.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">if</span>(v[i].cnt&lt;x)x-=v[i].cnt;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> v[i].v;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a_,ll n_,ll p_)</span> </span>&#123;<br>ll ans_=<span class="hljs-number">1</span>;<br>a_%=p_;<br><span class="hljs-keyword">while</span>(n_) &#123;<br><span class="hljs-keyword">if</span>(n_&amp;<span class="hljs-number">1</span>)ans_=ans_*a_%p_;<br>n_/=<span class="hljs-number">2</span>;<br>a_=a_*a_%p_;<br>&#125;<br><span class="hljs-keyword">return</span> ans_;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">getans_pow</span><span class="hljs-params">(ll l,ll r,ll x,ll y)</span> </span>&#123;<br>ll ans_=<span class="hljs-number">0</span>;<br>set&lt;node&gt;::iterator itr=<span class="hljs-built_in">split</span>(r+<span class="hljs-number">1</span>),itl=<span class="hljs-built_in">split</span>(l);<br><span class="hljs-keyword">for</span>(set&lt;node&gt;::iterator it=itl; it!=itr; it++) &#123;<br>ans_+=(<span class="hljs-built_in">qpow</span>(it-&gt;v,x,y)*(((it-&gt;r)-(it-&gt;l)+<span class="hljs-number">1</span>)%y))%y;<br>ans_%=y;<br>&#125;<br><span class="hljs-keyword">return</span> ans_%y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;seed&gt;&gt;vmax;<br><span class="hljs-built_in">random_</span>();<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(i,i,a[i]));<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=m; i++) &#123;<br><span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">add</span>(q[i].l,q[i].r,q[i].x);<br>&#125;<br><span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">assign</span>(q[i].l,q[i].r,q[i].x);<br>&#125;<br><span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">3</span>) &#123;<br>cout&lt;&lt;<span class="hljs-built_in">search</span>(q[i].l,q[i].r,q[i].x)&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">if</span>(q[i].op==<span class="hljs-number">4</span>) &#123;<br>cout&lt;&lt;(<span class="hljs-built_in">getans_pow</span>(q[i].l,q[i].r,q[i].x,q[i].y)+q[i].y)%q[i].y&lt;&lt;endl;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>解题题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.24-10.5 期间总结</title>
    <link href="/2023/10/05/9-24-10-5-%E6%9C%9F%E9%97%B4%E6%80%BB%E7%BB%93/"/>
    <url>/2023/10/05/9-24-10-5-%E6%9C%9F%E9%97%B4%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="期间总结">9.24 - 10.5 期间总结</h1><h2 id="序言">序言</h2><p>深窥自己的心，而后发觉一切的奇迹在你自己。</p><p>——<strong>培根</strong></p><span id="more"></span><h2 id="摸底考试">9.24 摸底考试</h2><p>这可能是我 <strong>OI</strong>生涯中经历的最糟糕的一场考试，考前时因为肚子不舒服，有点虚，加之CSP第一轮后状态直线下降，让我对这次考试有所担忧。考试中我先开了<span class="math inline">\(A\)</span> 题，<spanclass="math inline">\(A\)</span>题是一道关于位运算的题。我当时以为很水，敲了下手打高精度，以为就过了，但不曾想因为没有考虑到溢出的问题，<spanclass="math inline">\({\color{red}WA\ (0)}\)</span> 了。然后开了 <spanclass="math inline">\(C\)</span> 题，<spanclass="math inline">\(C\)</span>题是构造题，构造一个相邻两数之差或和的绝对值为质数的内部元素从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span>的序列。当时的方向想错了，以为是通过质数表暴搜得到，但时间会超，于是我想到了个自以为还行的<strong>伪解法</strong>，显然又 <span class="math inline">\({\color{red}WA\ (0)}\)</span>了。其他两道基本没想。最后的结果也<strong>爆零</strong>了。</p><h2 id="dp-1阶段-lcs-lis">DP 1阶段 (LCS &amp; LIS)</h2><p>在摸底考后几天时间里，老师和一些同学将作业表中 <spanclass="math inline">\(A\)</span> 到 <spanclass="math inline">\(E\)</span>题以及考试题讲述了一下，这里我见到了各种 <strong>dalao</strong>的各种方法，让我<del>大为</del>有所震惊。随后到国庆节又是一段空窗期，老师加了很多关于<strong>LIS</strong> 和 <strong>LCS</strong>的题，国庆节上课前两天也讲述了后面几道题的各种解法，让我的思维深度有了质的飞跃。但我<span class="math inline">\({\color{green} A}\)</span>的题还是很少，其中的 <span class="math inline">\(M\)</span>题死活过不去，这点我也无法理解。</p><h2 id="的小测试">10.5 的小测试</h2><p>赛前张老师说不希望我们爆零，于是我也为此提心吊胆，因为第一次我爆零了。考试的时候，又发生了一点小插曲，让我有点担忧。我先看了<span class="math inline">\(A\)</span> 题，<spanclass="math inline">\(A\)</span>题问纯色三角形的个数有多少。我第一时间想到了排列与组合，但想了很久也无法找到复杂度允许的算法，最后打了个<span class="math inline">\(O(n^3)\)</span> 的暴力骗点分。结果是 <spanclass="math inline">\({\color{red}WA\ (30)}\)</span>。随后我开了 <spanclass="math inline">\(B\)</span> 题，<spanclass="math inline">\(B\)</span>题有些难想，从体面上顺向思维是大概不会很轻松就想出来的，我发现反转操作是可逆的，于是我就想到从全<span class="math inline">\(0\)</span>给还原到图像，代码写完后算了下复杂度是 <spanclass="math inline">\(O(n^2)\)</span>，可以过掉。结果是 <spanclass="math inline">\({\color{green} AC\ (100)}\)</span>。<spanclass="math inline">\(C\)</span>题我当时没多想，最后才匆忙码，然后就成为全班唯一一个 <spanclass="math inline">\({\color{purplr} MLE\ (0)}\)</span>的人。<spanclass="math inline">\(D\)</span> 题原本我是推了 <spanclass="math inline">\(dp\)</span>公式，最后检查时发现读错题面了，这是一个重大失误，考场上出现非常致命。所以白白挂掉，时间又不够了，最后输出<span class="math inline">\(1\)</span> 想骗分，顺利 <spanclass="math inline">\({\color{red}WA\ (0)}\)</span>。总分 <spanclass="math inline">\(130\)</span>，不能说很好，但是有所进步。</p><h2 id="总结">总结</h2><p>这几天的表现并不好，或许是对环境的不适应，还是对自己过多的忧虑，希望可以将状态找回。</p><p>保持自信，相信自己，你会达成你的目标的！</p>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P1971 [NOI2011] 兔兔与蛋蛋游戏 题解</title>
    <link href="/2023/09/15/Luogu-P1971-NOI2011-%E5%85%94%E5%85%94%E4%B8%8E%E8%9B%8B%E8%9B%8B%E6%B8%B8%E6%88%8F-%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/09/15/Luogu-P1971-NOI2011-%E5%85%94%E5%85%94%E4%B8%8E%E8%9B%8B%E8%9B%8B%E6%B8%B8%E6%88%8F-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="传送门">传送门</h1><p><a href="https://www.luogu.com.cn/problem/P1971">P1971 [NOI2011]兔兔与蛋蛋游戏</a></p><h1 id="解决思路">解决思路</h1><p>对于每次移动，我们可以将它理解为空格在移动，同时有一个结论，空格的移动不可能出现环，即不重复的经过部分点，证明如下：</p><span id="more"></span><p>我们先假设空格的移动会出现环，不妨设其起点为 <spanclass="math inline">\(s_1\)</span>，那么再设经过 <spanclass="math inline">\(k\)</span> 次过后回到 <spanclass="math inline">\(s_1\)</span>，中间经过 <spanclass="math inline">\(s_1,s_2,s_3,\text{…},s_{k+1}\)</span> 后回到 <spanclass="math inline">\(s_1\)</span>。这个环因为是在棋盘上的，那我们就可以知道这个环的周长为<span class="math inline">\(2l (l \inR)\)</span>。如果格子里填的是黑棋子，那么经过偶数步我们当前必然只能走白格子，所以所设结论错误，所以空格的移动不可能出现环。</p><p>既然如此，我们也可以知道其实就是二分图博弈，就是套模板，这道题就做完了。</p><h1 id="ac-code">AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//二分图博弈模板</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long </span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">80</span>; <br>ll n,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>ll x,y,next;<br>&#125;e[N*N*<span class="hljs-number">2</span>];<br><span class="hljs-function">ll <span class="hljs-title">gethash</span><span class="hljs-params">(ll x,ll y)</span></span>&#123;<br><span class="hljs-keyword">return</span> (x<span class="hljs-number">-1</span>)*m+y;<br>&#125;<br>ll tot;<br>ll link[N*N*<span class="hljs-number">2</span>];<br>ll elast[N*N*<span class="hljs-number">2</span>];<br>ll del[N*N*<span class="hljs-number">2</span>];<br>ll ans[<span class="hljs-number">1010</span>]; <br>ll rans[<span class="hljs-number">1010</span>];<br><span class="hljs-type">bool</span> visit[N*N*<span class="hljs-number">2</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ll x,ll y)</span></span>&#123;<br>tot++;<br>e[tot].x=x;<br>e[tot].y=y;<br>e[tot].next=elast[x];<br>elast[x]=tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hungarian</span><span class="hljs-params">(ll id)</span></span>&#123;/匈牙利算法<br>ll x=id,y;<br>visit[x]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(ll i=elast[x];i;i=e[i].next)&#123;<br>y=e[i].y;<br><span class="hljs-keyword">if</span>(visit[y]||del[y])<span class="hljs-keyword">continue</span>;<br>visit[y]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(!link[y]||<span class="hljs-built_in">hungarian</span>(link[y]))&#123;<br>link[y]=x;<br>link[x]=y;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>ll k;<br><span class="hljs-type">char</span> Map[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">memset</span>(visit,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visit));<br>&#125;<br>ll x,y;<span class="hljs-comment">//空格位置 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(ll id)</span></span>&#123;<br>ll pointt=<span class="hljs-built_in">gethash</span>(x,y);<br>del[pointt]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(link[pointt]==<span class="hljs-number">0</span>)&#123;<br>ans[id]=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>ll point2=link[pointt];<br>link[point2]=link[pointt]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">hungarian</span>(point2))ans[id]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> ans[id]=<span class="hljs-number">1</span>;<br>&#125;<br>cin&gt;&gt;x&gt;&gt;y;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>cin&gt;&gt;Map[i][j];<br><span class="hljs-keyword">if</span>(Map[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)&#123;<br>x=i;<br>y=j;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(Map[i][j]==<span class="hljs-string">&#x27;O&#x27;</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(i!=<span class="hljs-number">1</span>&amp;&amp;Map[i<span class="hljs-number">-1</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>)&#123;<span class="hljs-comment">//X/.连O </span><br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">gethash</span>(i,j),<span class="hljs-built_in">gethash</span>(i<span class="hljs-number">-1</span>,j));<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">gethash</span>(i<span class="hljs-number">-1</span>,j),<span class="hljs-built_in">gethash</span>(i,j));<br>&#125;<br><span class="hljs-keyword">if</span>(i!=n&amp;&amp;Map[i+<span class="hljs-number">1</span>][j]==<span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">gethash</span>(i,j),<span class="hljs-built_in">gethash</span>(i+<span class="hljs-number">1</span>,j));<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">gethash</span>(i+<span class="hljs-number">1</span>,j),<span class="hljs-built_in">gethash</span>(i,j));<br>&#125;<br><span class="hljs-keyword">if</span>(j!=<span class="hljs-number">1</span>&amp;&amp;Map[i][j<span class="hljs-number">-1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">gethash</span>(i,j),<span class="hljs-built_in">gethash</span>(i,j<span class="hljs-number">-1</span>));<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">gethash</span>(i,j<span class="hljs-number">-1</span>),<span class="hljs-built_in">gethash</span>(i,j));<br>&#125;<br><span class="hljs-keyword">if</span>(j!=m&amp;&amp;Map[i][j+<span class="hljs-number">1</span>]==<span class="hljs-string">&#x27;O&#x27;</span>)&#123;<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">gethash</span>(i,j),<span class="hljs-built_in">gethash</span>(i,j+<span class="hljs-number">1</span>));<br><span class="hljs-built_in">add</span>(<span class="hljs-built_in">gethash</span>(i,j+<span class="hljs-number">1</span>),<span class="hljs-built_in">gethash</span>(i,j));<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(Map[i][j]!=<span class="hljs-string">&#x27;O&#x27;</span>)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">hungarian</span>(<span class="hljs-built_in">gethash</span>(i,j));<br>&#125;<br>&#125;<br>cin&gt;&gt;k;<br>ll cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">2</span>*k;i++)&#123;<br><span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="hljs-built_in">solve</span>(i);<br><span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>&amp;&amp;ans[i]==<span class="hljs-number">1</span>&amp;&amp;ans[i<span class="hljs-number">-1</span>]==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//判断是否犯错误</span><br>cnt++;<br>rans[cnt]=i/<span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br>cout&lt;&lt;cnt&lt;&lt;endl;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)&#123;<br>cout&lt;&lt;rans[i]&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>解题题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P6995 [NEERC2014] Knockout Racing 题解</title>
    <link href="/2023/08/17/Luogu-P6995-NEERC2014-Knockout-Racing-%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/17/Luogu-P6995-NEERC2014-Knockout-Racing-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目链接">题目链接</h1><p><a href="https://www.luogu.com.cn/problem/P6995">题 目 链 接</a></p><span id="more"></span><h1 id="分析">分析</h1><p>纯暴力 <span class="math inline">\(O(n^2)\)</span>就可以过，对于每次询问，先计算每辆车在 <spanclass="math inline">\(t\)</span> 秒后的所在位置，如果车是从 <spanclass="math inline">\(a\)</span> 点过去（即 <spanclass="math inline">\(\displaystyle\frac{t}{b-a}\)</span>为偶数），所在位置就应是 <spanclass="math inline">\(t\bmod(b-a)\)</span>，如是从 <spanclass="math inline">\(b\)</span> 点回来（即 <spanclass="math inline">\(\displaystyle\frac{t}{b-a}\)</span>为奇数），所在位置就为 <spanclass="math inline">\(t-t\bmod(b-a)\)</span>。再判断所在位置是否在询问的区间内即可。</p><h1 id="ac-code">AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">1010</span>,M=<span class="hljs-number">1010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>ll a,b;<br>&#125;e[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">qu</span>&#123;<br>ll x,y,t;<br>&#125;ques[M];<br>ll n,m; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;e[i].a&gt;&gt;e[i].b;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>cin&gt;&gt;ques[i].x&gt;&gt;ques[i].y&gt;&gt;ques[i].t;<br>ll ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>ll difference=e[j].b-e[j].a;<span class="hljs-comment">//a,b两端点距离 </span><br>ll to_back=ques[i].t/difference;<span class="hljs-comment">//往返次数 </span><br>ll meter=e[j].a+(to_back%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>?ques[i].t%difference:difference-ques[i].t%difference);<span class="hljs-comment">//所在位置</span><br><span class="hljs-keyword">if</span>(meter&gt;=ques[i].x&amp;&amp;ques[i].y&gt;=meter) &#123;<br>ans++;<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>解题题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P2328 [SCOI2005] 超级格雷码 题解</title>
    <link href="/2023/08/08/Luogu-P2328-SCOI2005-%E8%B6%85%E7%BA%A7%E6%A0%BC%E9%9B%B7%E7%A0%81-%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/08/Luogu-P2328-SCOI2005-%E8%B6%85%E7%BA%A7%E6%A0%BC%E9%9B%B7%E7%A0%81-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="题目">题目</h1><p><a href="https://www.luogu.com.cn/problem/P2328">题目链接。</a></p><h1 id="简述">简述</h1><p>输出 <span class="math inline">\(B\)</span> 进制 <spanclass="math inline">\(n\)</span> 位的所有格雷码。</p><span id="more"></span><h1 id="思考">思考</h1><p>通过观察，我们发现第 <span class="math inline">\(x\)</span>个格雷码的第 <span class="math inline">\(n\)</span> 位为 <spanclass="math inline">\(\lfloor \displaystyle \frac{x-1}{B^{n-1}}\rfloor\)</span>，第 <span class="math inline">\(n-i\)</span> 位 <spanclass="math inline">\((i&gt;0)\)</span> 其实要从第 <spanclass="math inline">\(n\)</span> 位到第 <spanclass="math inline">\(n-i+1\)</span> 位之和判断，如果第 <spanclass="math inline">\(n\)</span> 位到第 <spanclass="math inline">\(n-i+1\)</span> 位之和为偶数,则第 <spanclass="math inline">\(n-i\)</span> 位为 <spanclass="math inline">\(\lfloor \displaystyle \frac{(x-1) \bmodB^{n-i}}{B^{n-i-1}} \rfloor\)</span>，否则如果是奇数则 <spanclass="math inline">\(n-i\)</span> 位为 $B-1- $。</p><h1 id="ac-code">AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br>ll n,B; <br>ll even_odd; <span class="hljs-comment">//判断前面的数的奇偶性。 </span><br>ll ans[<span class="hljs-number">1110</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//输出 </span><br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(ans[i]&gt;<span class="hljs-number">9</span>)cout&lt;&lt;(<span class="hljs-type">char</span>)(ans[i]<span class="hljs-number">-10</span>+<span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">else</span> cout&lt;&lt;ans[i];<br>&#125;<br>cout&lt;&lt;endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a,ll b)</span></span>&#123;<span class="hljs-comment">//快速幂 </span><br>ll ans=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(b&gt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>)ans*=a;<br>b/=<span class="hljs-number">2</span>;<br>a*=a; <br>&#125; <br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;B;<br><span class="hljs-keyword">for</span>(ll x=<span class="hljs-number">1</span>;x&lt;=<span class="hljs-built_in">qpow</span>(B,n);x++)&#123;<br>ans[<span class="hljs-number">1</span>]=(x<span class="hljs-number">-1</span>)/<span class="hljs-built_in">qpow</span>(B,n<span class="hljs-number">-1</span>);<br>even_odd=ans[<span class="hljs-number">1</span>]%<span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>ans[i]=(even_odd%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>?(((x<span class="hljs-number">-1</span>)%<span class="hljs-built_in">qpow</span>(B,n-i+<span class="hljs-number">1</span>)))/<span class="hljs-built_in">qpow</span>(B,n-i):B<span class="hljs-number">-1</span>-(((x<span class="hljs-number">-1</span>)%<span class="hljs-built_in">qpow</span>(B,n-i+<span class="hljs-number">1</span>)))/<span class="hljs-built_in">qpow</span>(B,n-i));<span class="hljs-comment">//通过公式可知 </span><br>even_odd+=(ans[i]%<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-built_in">print</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>解题题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P4513 小白逛公园 题解~</title>
    <link href="/2023/08/07/Luogu-P4513-%E5%B0%8F%E7%99%BD%E9%80%9B%E5%85%AC%E5%9B%AD-%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/07/Luogu-P4513-%E5%B0%8F%E7%99%BD%E9%80%9B%E5%85%AC%E5%9B%AD-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前置芝士">前置芝士</h1><ul><li><p>线段树</p></li><li><p><del>一定量的大脑</del></p></li></ul><h1 id="题目">题目</h1><p><a href="https://www.bilibili.com/video/BV1yL411K7CP/"><del>链 接 地址 (大雾</del></a></p><p><a href="https://www.luogu.com.cn/problem/P4513">真 正 的 链接</a></p><span id="more"></span><h1 id="简述">简述</h1><p>给定一段共有 <span class="math inline">\(n\)</span>个点的线段，每个点都有一个值，现有 <spanclass="math inline">\(m\)</span> 次，<spanclass="math inline">\(2\)</span> 种操作：</p><ol type="1"><li><p>形如 $ 1 a b $，求值操作，求 <span class="math inline">\([\ a ,b\]\)</span> 区间内最大子序列和。</p></li><li><p>形如 $ 2 p s $，修改操作，将点 <spanclass="math inline">\(p\)</span> 的值修改为 <spanclass="math inline">\(s\)</span> 。</p></li></ol><p>对于每次 <span class="math inline">\(1\)</span>号操作，输出其区间内最大子序列和 <spanclass="math inline">\(ans\)</span>。</p><h1 id="思考">思考</h1><!--more--><p>如果我们用正常的方法求区间最大值，时间复杂度为 <spanclass="math inline">\(O(N)\)</span>，显然如果执行 <spanclass="math inline">\(m\)</span>次肯定会超时，我们就可以用一种高端大气时间复杂度仅为 <spanclass="math inline">\(O(log_2N)\)</span> 复杂度的算法：线段树。</p><h2 id="建树">建树</h2><p>不用多解释，上代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(ll id)</span></span>&#123;<span class="hljs-comment">//上提操作</span><br>Tree[id].sum=Tree[id*<span class="hljs-number">2</span>].sum+Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum;<br>Tree[id].l1=<span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>].sum+Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].l1,Tree[id*<span class="hljs-number">2</span>].l1);<span class="hljs-comment">//l1，r1作用下文会提及。</span><br>Tree[id].r1=<span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum+Tree[id*<span class="hljs-number">2</span>].r1,Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].r1);<br>Tree[id].max=<span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].max,<span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>].max,Tree[id*<span class="hljs-number">2</span>].r1+Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].l1));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll id,ll l,ll r)</span></span>&#123;<span class="hljs-comment">//建树过程</span><br>Tree[id].l=l;Tree[id].r=r;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>Tree[id].max=Tree[id].l1=Tree[id].r1=Tree[id].sum=a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">build</span>(id*<span class="hljs-number">2</span>,l,mid);<br><span class="hljs-built_in">build</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">up</span>(id);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="修改操作">修改操作</h2><p>既然只修改一个点的值，那肯定就用线段树的单点修改就 <spanclass="math inline">\(OK\)</span> 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(ll id,ll x,ll num)</span></span>&#123;<span class="hljs-comment">//单点修改</span><br><span class="hljs-keyword">if</span>(Tree[id].l==Tree[id].r)&#123;<br>Tree[id].max=Tree[id].l1=Tree[id].r1=Tree[id].sum=num;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid=(Tree[id].l+Tree[id].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid)<span class="hljs-built_in">change</span>(id*<span class="hljs-number">2</span>,x,num);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,x,num);<br><span class="hljs-built_in">up</span>(id);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="求和操作">求和操作</h2><p>枚举到一个节点时有如下几种情况：</p><ol type="1"><li>该节点位于所求区间内，返回。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(l&lt;=Tree[id].l&amp;&amp;r&gt;=Tree[id].r)&#123;<span class="hljs-comment">//位于区间内</span><br><span class="hljs-keyword">return</span> Tree[id].max;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>区间位于该节点左儿子内部，枚举该节点左儿子。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ll anss=<span class="hljs-number">-1e17</span>;<span class="hljs-comment">//答案</span><br><span class="hljs-keyword">if</span>(Tree[id*<span class="hljs-number">2</span>].l&lt;=r&amp;&amp;Tree[id*<span class="hljs-number">2</span>].r&gt;=l)anss=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">GetSum</span>(id*<span class="hljs-number">2</span>,l,r),anss);<span class="hljs-comment">//左儿子包含所求区间</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>区间位于该节点右儿子内部，枚举该节点右儿子。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].l&lt;=r&amp;&amp;Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].r&gt;=l)anss=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">GetSum</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r),anss);<span class="hljs-comment">//右儿子包含所求区间</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>区间与左儿子，右儿子都有交集，则我们设一个节点的 <spanclass="math inline">\(l1\)</span> 为从左起的一段最大值， <spanclass="math inline">\(r1\)</span>为从右起的一段最大值。随后可以用递归来求最大的从中间部分起左、右边部分区间和最大值，再合并求得最大值。</li></ol><h3 id="递归过程">递归过程</h3><p>有两侧的递归，这里分开来讲。</p><h4 id="左递归">左递归</h4><p>首先先看左儿子有如下情况：</p><ol type="1"><li><p>如果这个节点的左儿子在所要求区间的左侧要小，递归结束，代表这个节点的<span class="math inline">\(r1\)</span>值即是其目前递归的值，返回。</p></li><li><p>如果该节点的右儿子是被其要求区间完全覆盖（即所要求区间的左、右端点与其右儿子的左、右端点重合），则其最大值要么是其右儿子的<span class="math inline">\(r1\)</span>值，要么是右儿子的总和加上其左儿子的递归结果，从中取最大即可。</p></li><li><p>如果该节点的右儿子是被其要求区间覆盖（但所要求区间的左端点与其右儿子的左端点不重合，也就是说该节点的左儿子并没有包含所要求区间），递归右儿子，取其值。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">Tree_num_l</span><span class="hljs-params">(ll id,ll l)</span></span>&#123;<br>ll mid=(Tree[id].l+Tree[id].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(l&lt;=Tree[id].l)&#123;<span class="hljs-comment">//情况1</span><br><span class="hljs-keyword">return</span> Tree[id].r1;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&lt;=mid)&#123;<span class="hljs-comment">//情况2</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].r1,Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum+<span class="hljs-built_in">Tree_num_l</span>(id*<span class="hljs-number">2</span>,l));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//情况3</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Tree_num_l</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="右递归">右递归</h4><p>和左递归差不多，不过要改点细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">Tree_num_r</span><span class="hljs-params">(ll id,ll r)</span></span>&#123;<br>ll mid=(Tree[id].l+Tree[id].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(r&gt;=Tree[id].r)&#123;<span class="hljs-comment">//情况1</span><br><span class="hljs-keyword">return</span> Tree[id].l1;<br>&#125;<br><span class="hljs-keyword">if</span>(r&gt;=mid)&#123;<span class="hljs-comment">//情况2</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>].l1,Tree[id*<span class="hljs-number">2</span>].sum+<span class="hljs-built_in">Tree_num_r</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,r));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//情况3</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Tree_num_r</span>(id*<span class="hljs-number">2</span>,r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>这是递归过程的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(l&lt;=Tree[id*<span class="hljs-number">2</span>].r&amp;&amp;Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].l&lt;=r)&#123;<br>ll ansss=<span class="hljs-number">0</span>;<br>ansss+=<span class="hljs-built_in">Tree_num_l</span>(id*<span class="hljs-number">2</span>,l);<br>ansss+=<span class="hljs-built_in">Tree_num_r</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,r);<br>anss=<span class="hljs-built_in">max</span>(ansss,anss);<br>&#125;<br></code></pre></td></tr></table></figure><hr /><h1 id="ac-code">AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">500000</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>ll l,r,l1,r1,max,sum;<br>&#125;Tree[<span class="hljs-number">16</span>*N];<br>ll a[N],n,m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(ll id)</span></span>&#123;<span class="hljs-comment">//上提操作</span><br>Tree[id].sum=Tree[id*<span class="hljs-number">2</span>].sum+Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum;<br>Tree[id].l1=<span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>].sum+Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].l1,Tree[id*<span class="hljs-number">2</span>].l1);<span class="hljs-comment">//l1，r1作用下文会提及。</span><br>Tree[id].r1=<span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum+Tree[id*<span class="hljs-number">2</span>].r1,Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].r1);<br>Tree[id].max=<span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].max,<span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>].max,Tree[id*<span class="hljs-number">2</span>].r1+Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].l1));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll id,ll l,ll r)</span></span>&#123;<span class="hljs-comment">//建树过程</span><br>Tree[id].l=l;Tree[id].r=r;<br><span class="hljs-keyword">if</span>(l==r)&#123;<br>Tree[id].max=Tree[id].l1=Tree[id].r1=Tree[id].sum=a[l];<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid=(l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-built_in">build</span>(id*<span class="hljs-number">2</span>,l,mid);<br><span class="hljs-built_in">build</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,mid+<span class="hljs-number">1</span>,r);<br><span class="hljs-built_in">up</span>(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(ll id,ll x,ll num)</span></span>&#123;<span class="hljs-comment">//单点修改</span><br><span class="hljs-keyword">if</span>(Tree[id].l==Tree[id].r)&#123;<br>Tree[id].max=Tree[id].l1=Tree[id].r1=Tree[id].sum=num;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>ll mid=(Tree[id].l+Tree[id].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(x&lt;=mid)<span class="hljs-built_in">change</span>(id*<span class="hljs-number">2</span>,x,num);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">change</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,x,num);<br><span class="hljs-built_in">up</span>(id);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">Tree_num_l</span><span class="hljs-params">(ll id,ll l)</span></span>&#123;<br>ll mid=(Tree[id].l+Tree[id].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(l&lt;=Tree[id].l)&#123;<span class="hljs-comment">//情况1</span><br><span class="hljs-keyword">return</span> Tree[id].r1;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l&lt;=mid)&#123;<span class="hljs-comment">//情况2</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].r1,Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].sum+<span class="hljs-built_in">Tree_num_l</span>(id*<span class="hljs-number">2</span>,l));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//情况3</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Tree_num_l</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l);<br>&#125;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">Tree_num_r</span><span class="hljs-params">(ll id,ll r)</span></span>&#123;<br>ll mid=(Tree[id].l+Tree[id].r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(r&gt;=Tree[id].r)&#123;<span class="hljs-comment">//情况1</span><br><span class="hljs-keyword">return</span> Tree[id].l1;<br>&#125;<br><span class="hljs-keyword">if</span>(r&gt;=mid)&#123;<span class="hljs-comment">//情况2</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(Tree[id*<span class="hljs-number">2</span>].l1,Tree[id*<span class="hljs-number">2</span>].sum+<span class="hljs-built_in">Tree_num_r</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,r));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//情况3</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Tree_num_r</span>(id*<span class="hljs-number">2</span>,r);<br>&#125;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">GetSum</span><span class="hljs-params">(ll id,ll l,ll r)</span></span>&#123;<br><span class="hljs-keyword">if</span>(l&lt;=Tree[id].l&amp;&amp;r&gt;=Tree[id].r)&#123;<br><br>ll ansss=Tree[id].max;<br><span class="hljs-keyword">return</span> ansss;<br>&#125;<br>ll anss=<span class="hljs-number">-1e17</span>;<br><span class="hljs-keyword">if</span>(Tree[id*<span class="hljs-number">2</span>].l&lt;=r&amp;&amp;Tree[id*<span class="hljs-number">2</span>].r&gt;=l)anss=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">GetSum</span>(id*<span class="hljs-number">2</span>,l,r),anss);<br><span class="hljs-keyword">if</span>(Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].l&lt;=r&amp;&amp;Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].r&gt;=l)anss=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">GetSum</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,l,r),anss);<br><span class="hljs-keyword">if</span>(l&lt;=Tree[id*<span class="hljs-number">2</span>].r&amp;&amp;Tree[id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>].l&lt;=r)&#123;<br>ll ansss=<span class="hljs-number">0</span>;<br>ansss+=<span class="hljs-built_in">Tree_num_l</span>(id*<span class="hljs-number">2</span>,l);<br>ansss+=<span class="hljs-built_in">Tree_num_r</span>(id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>,r);<br>anss=<span class="hljs-built_in">max</span>(ansss,anss);<br>&#125;<br><span class="hljs-keyword">return</span> anss;<br>&#125;<br>ll x,l,r;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>),cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br><span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>cin&gt;&gt;x;<br><span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>)&#123;<br>cin&gt;&gt;l&gt;&gt;r;<br>cout&lt;&lt;<span class="hljs-built_in">GetSum</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">min</span>(l,r),<span class="hljs-built_in">max</span>(l,r))&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>cin&gt;&gt;l&gt;&gt;r;<br><span class="hljs-built_in">change</span>(<span class="hljs-number">1</span>,l,r);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>解题题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P3623 [APIO2008] 免费道路 题解</title>
    <link href="/2023/08/04/Luogu-P3623-APIO2008-%E5%85%8D%E8%B4%B9%E9%81%93%E8%B7%AF-%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/04/Luogu-P3623-APIO2008-%E5%85%8D%E8%B4%B9%E9%81%93%E8%B7%AF-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前置芝士">前置芝士</h1><ul><li><p>并查集</p></li><li><p><strong>Kruscal</strong> 重构树</p></li><li><p>图论基础知识</p></li></ul><h1 id="题目">题目</h1><p><a href="https://www.luogu.com.cn/problem/P3623">链接地址</a></p><span id="more"></span><h1 id="题目简述">题目简述</h1><p>给定两种边 <span class="math inline">\(stone,cement\)</span>。现有<span class="math inline">\(n\)</span> 个节点，共有 <spanclass="math inline">\(m\)</span>条<strong>不同种类</strong>的边连接，现需选择一些边，使这些节点互相连通，其中<span class="math inline">\(stone\)</span> 边为 <spanclass="math inline">\(K\)</span> 条。求连接边的道路总和最小的方案。</p><h1 id="思考">思考</h1><p>我们可以设某一种边全部都连接，则如果另一种边选择一部分边连接一些使这个图连通，则这些边肯定是必要的，既然是连通性问题，我们就可以用<strong>并查集</strong>解决是否连通。必要的边求出后，再考虑连通性并选择边连接，注意其中<span class="math inline">\(stone\)</span> 边有 <spanclass="math inline">\(K\)</span> 条即可。</p><h1 id="边界考虑">边界考虑</h1><p>如果求出来的 <span class="math inline">\(stone\)</span> 边的数量大于<span class="math inline">\(K\)</span> 的数量，显然是与题意要求恰好有<span class="math inline">\(K\)</span> 条边不符的，如果除 <spanclass="math inline">\(cement\)</span> 边的数量是小于 <spanclass="math inline">\(K\)</span> 的，则说明其 <spanclass="math inline">\(stone\)</span> 边的数量再怎么增加都会小于 <spanclass="math inline">\(K\)</span> ，即输出 no solution。</p><h1 id="ac-code">AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll M=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll N=<span class="hljs-number">2e4</span>+<span class="hljs-number">10</span>; <br>ll n,m,k,stone,cement,tot;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>ll x,y,z;<br>&#125;e[M],need[M]; <br>ll father[N];<br><span class="hljs-comment">//并查集。</span><br><span class="hljs-function">ll <span class="hljs-title">getfather</span><span class="hljs-params">(ll x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x==father[x]?x:father[x]=<span class="hljs-built_in">getfather</span>(father[x]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(ll x,ll y)</span></span>&#123;<span class="hljs-comment">//合并。</span><br>ll fx=<span class="hljs-built_in">getfather</span>(x);<br>ll fy=<span class="hljs-built_in">getfather</span>(y);<br><span class="hljs-keyword">if</span>(fx!=fy)&#123;<br>father[fx]=fy; <br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); <br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>father[i]=i;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>cin&gt;&gt;e[i].x&gt;&gt;e[i].y&gt;&gt;e[i].z; <br>&#125;<br>   <span class="hljs-comment">//先连接stone边</span><br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">if</span>(!e[i].z)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">getfather</span>(e[i].x)!=<span class="hljs-built_in">getfather</span>(e[i].y))&#123;<br><span class="hljs-built_in">Merge</span>(e[i].x,e[i].y);<br>&#125;<br>&#125;<br>&#125;<br>   <span class="hljs-comment">//检查连通性并储存                   </span><br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">if</span>(e[i].z)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">getfather</span>(e[i].x)!=<span class="hljs-built_in">getfather</span>(e[i].y))&#123;<br>cement++;<br>tot++;<br>need[tot].x=e[i].x;<br>need[tot].y=e[i].y; <br>need[tot].z=e[i].z;<br><span class="hljs-built_in">Merge</span>(e[i].x,e[i].y);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>father[i]=i;<br>&#125;<br>   <span class="hljs-comment">//连接cement边                      </span><br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">if</span>(e[i].z)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">getfather</span>(e[i].x)!=<span class="hljs-built_in">getfather</span>(e[i].y))&#123;<br><span class="hljs-built_in">Merge</span>(e[i].x,e[i].y);<br>&#125;<br>&#125;<br>&#125;<br>   <span class="hljs-comment">//检查连通性并储存</span><br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">if</span>(!e[i].z)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">getfather</span>(e[i].x)!=<span class="hljs-built_in">getfather</span>(e[i].y))&#123;<br>stone++;<br>tot++;<br>need[tot].x=e[i].x;<br>need[tot].y=e[i].y; <br>need[tot].z=e[i].z;<br><span class="hljs-built_in">Merge</span>(e[i].x,e[i].y);<br>&#125;<br>&#125;<br>&#125;<br>   <span class="hljs-comment">//边界考虑                      </span><br><span class="hljs-keyword">if</span>(stone&gt;k||cement&gt;n-k<span class="hljs-number">-1</span>)&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;no solution&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>father[i]=i;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=tot;i++)&#123;<br><span class="hljs-built_in">Merge</span>(need[i].x,need[i].y);<br>&#125;<br>   <span class="hljs-comment">//stone路的连接</span><br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>,j=<span class="hljs-number">1</span>;j&lt;=k-stone&amp;&amp;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">if</span>(!e[i].z)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">getfather</span>(e[i].x)!=<span class="hljs-built_in">getfather</span>(e[i].y))&#123;<br>tot++; <br>j++; <br><span class="hljs-comment">//cout&lt;&lt;j&lt;&lt;endl;</span><br>need[tot].x=e[i].x;<br>need[tot].y=e[i].y;<br>need[tot].z=e[i].z;<br><span class="hljs-built_in">Merge</span>(e[i].x,e[i].y);<br>&#125;<br>&#125;<br>&#125; <br>   <span class="hljs-comment">//cement路的连接</span><br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">if</span>(e[i].z)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">getfather</span>(e[i].x)!=<span class="hljs-built_in">getfather</span>(e[i].y))&#123;<br>tot++;  <br>need[tot].x=e[i].x;<br>need[tot].y=e[i].y;<br>need[tot].z=e[i].z;<br><span class="hljs-built_in">Merge</span>(e[i].x,e[i].y);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>;i&lt;=tot;i++)&#123;<br>cout&lt;&lt;need[i].x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;need[i].y&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;need[i].z&lt;&lt;endl;<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>解题题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Luogu P2986 [USACO10MAR] Great Cow Gathering G 题解</title>
    <link href="/2023/08/03/Luogu-P2986-USACO10MAR-Great-Cow-Gathering-G-%E9%A2%98%E8%A7%A3/"/>
    <url>/2023/08/03/Luogu-P2986-USACO10MAR-Great-Cow-Gathering-G-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前置芝士">前置芝士</h1><ul><li><p>DFS</p></li><li><p>图论基础知识</p></li></ul><span id="more"></span><h1 id="题目">题目</h1><p><a href="https://www.luogu.com.cn/problem/P2986">题目链接。</a></p><h1 id="题目超短的简述">题目<del>超短的</del>简述</h1><p>给出一棵树，每个节点都有一个权值。现选择一点 <spanclass="math inline">\(X\)</span>作为根节点，则其不方便值为其它点的权值乘上距离点 <spanclass="math inline">\(X\)</span> 的长度之和，求最小的不方便值。</p><h1 id="思考">思考</h1><p>本题给出了一棵树，不妨设根节点为 <spanclass="math inline">\(1\)</span> ，先求出每个节点 <spanclass="math inline">\(i\)</span> 有多少头儿子奶牛 <spanclass="math inline">\(sonnum_i\)</span>（包括自己），在从根节点开始寻找，如果节点的儿子 <spanclass="math inline">\(son_{i}\)</span> 所包含的奶牛数量 <spanclass="math inline">\(sonnum_{son_{i}}\)</span> 大于其他奶牛的数量，则代表如果选择这个点作为集会点，其 <spanclass="math inline">\(son_{i}\)</span>的儿子少走的距离会比其他的点多走的距离要多，表明如果选择此点会让不方便值更小，我们就可以从这个点再次重复搜索过程，直到不能再搜索，表明这个点是<strong>目前搜索</strong>的最优值。这个过程可以用DFS来实现,最后搜索出来的点<strong>可能会有很多</strong>，可以一个一个搜索出它们的最小不方便值，也可用DFS来实现。对于那些还没有学过树形DP的人相对而言会易于理解（肯定会比树形DP要慢）。</p><h1 id="ac-code">AC Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N=<span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>ll x,y,z;<br>&#125; e[N*<span class="hljs-number">2</span>+<span class="hljs-number">10</span>];<br>ll st[N],en[N],son[N],son_num;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a.x&lt;b.x;<br>&#125;<br><span class="hljs-type">bool</span> mark[N],markk[N];<br>ll cows[N],x,y,z,n,num,ans,anss=<span class="hljs-number">100000000000000000</span>;<br><span class="hljs-function">ll <span class="hljs-title">dfs1</span><span class="hljs-params">(ll id,ll sum)</span> </span>&#123;<span class="hljs-comment">//求得每个节点子树的儿子个数。 </span><br><span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(ll i=st[id]; i&lt;=en[id]; i++) &#123;<br><span class="hljs-keyword">if</span>(!mark[e[i].y]) &#123;<br>flag=<span class="hljs-number">1</span>;<br>mark[id]=<span class="hljs-number">1</span>;<br>sum+=<span class="hljs-built_in">dfs1</span>(e[i].y,<span class="hljs-number">0</span>);<br>mark[e[i].y]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>son[id]=sum+cows[id];<br><span class="hljs-keyword">return</span> sum+cows[id];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getans</span><span class="hljs-params">(ll id,ll numm)</span> </span>&#123;<span class="hljs-comment">//求得以id节点为集会地点时的不方便程度。 </span><br><span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(cows[id])ans+=numm*cows[id];<br><span class="hljs-keyword">for</span>(ll i=st[id]; i&lt;=en[id]; i++) &#123;<br><span class="hljs-keyword">if</span>(!markk[e[i].y])&#123;<br>markk[id]=<span class="hljs-number">1</span>;<br>flag=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">getans</span>(e[i].y,numm+e[i].z);<br>markk[id]=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(ll id)</span> </span>&#123;<span class="hljs-comment">//求得有哪些点满足最优条件。 </span><br><span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<span class="hljs-comment">//flag来判断是否是目前搜索的最优点。</span><br><span class="hljs-keyword">for</span>(ll i=st[id]; i&lt;=en[id]; i++) &#123;<br><span class="hljs-keyword">if</span>(son[e[i].y]&gt;=son_num-son[e[i].y]&amp;&amp;!mark[e[i].y]) &#123;<span class="hljs-comment">//这里检测儿子节点所包含的奶牛数量是否比其他奶牛大。</span><br>flag=<span class="hljs-number">1</span>;<br>mark[id]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(e[i].y);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(!flag)&#123;<br><span class="hljs-built_in">memset</span>(markk,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(markk));<br>ans=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">getans</span>(id,<span class="hljs-number">0</span>);<br>anss=<span class="hljs-built_in">min</span>(ans,anss);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;=n; i++) &#123;<br>cin&gt;&gt;cows[i];<br>son_num+=cows[i];<br>&#125;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">1</span>; i&lt;n; i++) &#123;<br>cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;<br>e[i].x=x,e[i].y=y,e[i].z=z;<br>e[i+n<span class="hljs-number">-1</span>].x=y,e[i+n<span class="hljs-number">-1</span>].y=x,e[i+n<span class="hljs-number">-1</span>].z=z;<br>&#125;<br><span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>,cmp);<br>st[e[<span class="hljs-number">1</span>].x]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(ll i=<span class="hljs-number">2</span>; i&lt;=<span class="hljs-number">2</span>*n<span class="hljs-number">-2</span>; i++) &#123;<br><span class="hljs-keyword">if</span>(e[i].x!=e[i<span class="hljs-number">-1</span>].x)&#123;<br>en[e[i<span class="hljs-number">-1</span>].x]=i<span class="hljs-number">-1</span>;<br>st[e[i].x]=i;<br>&#125;<br>&#125;<br>en[n]=n*<span class="hljs-number">2</span><span class="hljs-number">-2</span>;<br>   <span class="hljs-comment">//作者忘了链式向前星怎么写，这段大家应该都能看懂。 </span><br>    <span class="hljs-built_in">memset</span>(mark,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(mark));<br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//求得每个节点子树的儿子个数。 </span><br><span class="hljs-built_in">memset</span>(mark,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(mark));<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//求得有哪些点满足最优条件，这里一并求值。 </span><br>cout&lt;&lt;anss&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="附">附</h1><p>这是本蒻的第一篇题解，有任何错误都可以在评论区指出。</p>]]></content>
    
    
    <categories>
      
      <category>解题题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构学习笔记1——线段树</title>
    <link href="/2023/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2023/07/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>一种数据结构，适用于在线修改区间，求区间最值，区间求和问题等。</p><p>本质上是一棵二叉树。</p><p><strong>优点：维护内容多样，易于理解。</strong></p><p><strong>缺点：常数太大，码量较大，空间较大。</strong></p><h1 id="算法">算法</h1><h2 id="储存建树">储存+建树</h2><p>线段树之所以叫线段树，是因为它里面的每个节点存储了一部分区间（<del>照理来说应该取名为区间树但为啥要叫线段树</del>），储存了这一段区间的一些信息。前面提到，线段树本质上是一棵二叉树，于是每一个父节点被劈成两半，它的区间也要被劈成两半。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//结构体定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tree</span><br>&#123;<br>    ll l, r;<br>    ll v;<span class="hljs-comment">//你要维护的信息，这里均用区间和表示</span><br>    ll lazy;<span class="hljs-comment">//后面会写</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的结构体储存了树的节点的左右端点以及要维护的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//建范围 [l,r] 的树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll id, ll l, ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree[id].l = l;<br>    Tree[id].r = r;<br>    <span class="hljs-keyword">if</span> (l == r)<br>    &#123;<br>        <span class="hljs-comment">//加上初始化的内容。</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ll mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">build</span>(id * <span class="hljs-number">2</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-comment">//Tree[id].v = Tree[id * 2].v + Tree[id * 2 + 1];</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是一个建树的过程，大区间被劈开成为小的区间。</p><p>建树的时间复杂度就是树的节点数，复杂度为 <spanclass="math inline">\(O(n)\)</span>。</p><p><strong>注意：假若你要在建树时初始化部分内容，初始化后要将初始化的东西上提到它的父节点（上面的注释）。</strong></p><h2 id="单点修改">单点修改</h2><p>我们可以通过递归，找到要修改的点的有且只有该点的区间，然后上提。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//单点修改 k 增加 x。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(ll id, ll k, ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[id].l == Tree[id].r)<br>    &#123;<br>        Tree[id].v += x;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (Tree[id].l + Tree[id].r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (k &lt;= mid)<span class="hljs-comment">//递归</span><br>    &#123;<br>        <span class="hljs-built_in">change</span>(id * <span class="hljs-number">2</span>, k, x);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">change</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, k, x);<br>    &#125;<br>    Tree[id].v = Tree[id * <span class="hljs-number">2</span>].v + Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].v;<span class="hljs-comment">//上提</span><br>&#125;<br></code></pre></td></tr></table></figure><p>单点修改所经过的点数为树的深度，也就是说时间复杂度为 <spanclass="math inline">\(O(\log n)\)</span>。</p><h2 id="区间修改">区间修改</h2><p>这是，我们就要引入一个新的东西，<spanclass="math inline">\(lazy\)</span>标记，如果我们像单点修改一样直接将所有的区间点更改，会牵扯到很多的点，使复杂度原地爆炸，而<span class="math inline">\(lazy\)</span>标记则是为了来降低时间复杂度（当然也让常数飙升），到了我们需要再求的时候，再用<span class="math inline">\(lazy\)</span> 更新儿子，并且传递下去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//下放编号为 id 的点。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(ll id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[id].l == Tree[id].r)<br>    &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Tree[id * <span class="hljs-number">2</span>].lazy += Tree[id].lazy;<br>    Tree[id * <span class="hljs-number">2</span>].v += Tree[id].v;<br>    Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].lazy += Tree[id].lazy;<br>    Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].v += Tree[id].v;<br>    Tree[id].lazy = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是其下放操作的代码，先将儿子的 <spanclass="math inline">\(lazy\)</span> 改为父亲的，再将其值更改，后将父亲的<code>lazy</code> 值清掉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//将区间 [l,r] 内的数都增加 x。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(ll id, ll l, ll r, ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[id].lazy)<br>    &#123;<br>        <span class="hljs-built_in">pushDown</span>(id);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &lt;= Tree[id].l &amp;&amp; Tree[id].r &lt;= r)<br>    &#123;<br>        Tree[id].v += x;<br>        Tree[id].lazy += x;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ll mid = (Tree[id].l + Tree[id].r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>    &#123;<br>        <span class="hljs-built_in">change</span>(id * <span class="hljs-number">2</span>, l, r, x);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>    &#123;<br>        <span class="hljs-built_in">change</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r, x);<br>    &#125;<br>    Tree[id].v = <span class="hljs-built_in">max</span>(Tree[id * <span class="hljs-number">2</span>].v, Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].v);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中，先检测有没有下放的必要，再更新，如果这段点包含在了<code>[l,r]</code> 中，就将该点更新，同时也要将 <spanclass="math inline">\(lazy\)</span> 值更新。</p><h2 id="区间查询">区间查询</h2><p>这个简单，只需要查询其树上连续的值拼接在一起就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//求区间 [l,r] 的和。</span><br><span class="hljs-function">ll <span class="hljs-title">GetSum</span><span class="hljs-params">(ll id, ll l, ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[id].lazy)<br>    &#123;<br>        <span class="hljs-built_in">pushDown</span>(id);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l &lt;= Tree[id].l &amp;&amp; r &gt;= Tree[id].r)<br>    &#123;<br>        <span class="hljs-keyword">return</span> Tree[id].v;<br>    &#125;<br>    ll mid = (Tree[id].l + Tree[id].r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>    &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">GetSum</span>(id * <span class="hljs-number">2</span>, l, r));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>    &#123;<br>        ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">GetSum</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="更多">更多</h2><p>详见例题。</p><h1 id="例题">例题</h1><h2 id="scoi2010-序列操作">[SCOI2010] 序列操作</h2><p><ahref="http://oi.nks.edu.cn:19360/zh/Problem/Details?cid=2383&amp;tid=M">LinkNKOJ</a> and <a href="https://www.luogu.com.cn/problem/P2572">LinkLuogu</a></p><p>这道题是线段树的经典例题，但是就是按照题意模拟即可，再需要注意的是不同操作之间的<span class="math inline">\(lazy\)</span> 值不一样，要替换或更改。</p><h3 id="ac-code">AC code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tree</span><br>&#123;<br>    ll l, r, l1_1, l1_0, r1_1, r1_0, sum, max1, max0, lazy;<br>&#125; Tree[N * <span class="hljs-number">16</span>];<br>ll n, m;<br>ll a[N];<br>ll flag, a_, b_;<br><span class="hljs-function">ll <span class="hljs-title">change</span><span class="hljs-params">(ll a, ll b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> b;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(ll id)</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree[id].sum = Tree[id * <span class="hljs-number">2</span>].sum + Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].sum;<br>    <span class="hljs-keyword">if</span> (Tree[id * <span class="hljs-number">2</span>].l1_1 &lt; Tree[id * <span class="hljs-number">2</span>].r - Tree[id * <span class="hljs-number">2</span>].l + <span class="hljs-number">1</span>)<br>        Tree[id].l1_1 = Tree[id * <span class="hljs-number">2</span>].l1_1;<br>    <span class="hljs-keyword">else</span><br>        Tree[id].l1_1 = Tree[id * <span class="hljs-number">2</span>].l1_1 + Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l1_1;<br>    <span class="hljs-keyword">if</span> (Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r1_1 &lt; Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r - Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l + <span class="hljs-number">1</span>)<br>        Tree[id].r1_1 = Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r1_1;<br>    <span class="hljs-keyword">else</span><br>        Tree[id].r1_1 = Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r1_1 + Tree[id * <span class="hljs-number">2</span>].r1_1;<br>    Tree[id].max1 = <span class="hljs-built_in">max</span>(Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].max1, <span class="hljs-built_in">max</span>(Tree[id * <span class="hljs-number">2</span>].max1, Tree[id * <span class="hljs-number">2</span>].r1_1 + Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l1_1));<br>    <span class="hljs-keyword">if</span> (Tree[id * <span class="hljs-number">2</span>].l1_0 &lt; Tree[id * <span class="hljs-number">2</span>].r - Tree[id * <span class="hljs-number">2</span>].l + <span class="hljs-number">1</span>)<br>        Tree[id].l1_0 = Tree[id * <span class="hljs-number">2</span>].l1_0;<br>    <span class="hljs-keyword">else</span><br>        Tree[id].l1_0 = Tree[id * <span class="hljs-number">2</span>].l1_0 + Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l1_0;<br>    <span class="hljs-keyword">if</span> (Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r1_0 &lt; Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r - Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l + <span class="hljs-number">1</span>)<br>        Tree[id].r1_0 = Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r1_0;<br>    <span class="hljs-keyword">else</span><br>        Tree[id].r1_0 = Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r1_0 + Tree[id * <span class="hljs-number">2</span>].r1_0;<br>    Tree[id].max0 = <span class="hljs-built_in">max</span>(Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].max0, <span class="hljs-built_in">max</span>(Tree[id * <span class="hljs-number">2</span>].max0, Tree[id * <span class="hljs-number">2</span>].r1_0 + Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l1_0));<br>    <span class="hljs-comment">// cout&lt;&lt;id&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].l&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].r&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].l1_1&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].r1_1&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].max1&lt;&lt;endl;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(ll id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[id].l == Tree[id].r)<br>        <span class="hljs-keyword">return</span>;<br>    Tree[id * <span class="hljs-number">2</span>].lazy = <span class="hljs-built_in">change</span>(Tree[id * <span class="hljs-number">2</span>].lazy, Tree[id].lazy);<br>    Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].lazy = <span class="hljs-built_in">change</span>(Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].lazy, Tree[id].lazy);<br>    <span class="hljs-keyword">if</span> (Tree[id].lazy != <span class="hljs-number">2</span>)<br>    &#123;<br>        Tree[id * <span class="hljs-number">2</span>].sum = Tree[id * <span class="hljs-number">2</span>].max1 = Tree[id * <span class="hljs-number">2</span>].l1_1 = Tree[id * <span class="hljs-number">2</span>].r1_1 = (Tree[id * <span class="hljs-number">2</span>].r - Tree[id * <span class="hljs-number">2</span>].l + <span class="hljs-number">1</span>) * Tree[id].lazy;<br>        Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].sum = Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].max1 = Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l1_1 = Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r1_1 = (Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r - Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l + <span class="hljs-number">1</span>) * Tree[id].lazy;<br>        Tree[id * <span class="hljs-number">2</span>].max0 = Tree[id * <span class="hljs-number">2</span>].l1_0 = Tree[id * <span class="hljs-number">2</span>].r1_0 = (Tree[id * <span class="hljs-number">2</span>].r - Tree[id * <span class="hljs-number">2</span>].l + <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> - Tree[id].lazy);<br>        Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].max0 = Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l1_0 = Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r1_0 = (Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r - Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l + <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> - Tree[id].lazy);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        Tree[id * <span class="hljs-number">2</span>].sum = (Tree[id * <span class="hljs-number">2</span>].r - Tree[id * <span class="hljs-number">2</span>].l + <span class="hljs-number">1</span>) - Tree[id * <span class="hljs-number">2</span>].sum;<br>        <span class="hljs-built_in">swap</span>(Tree[id * <span class="hljs-number">2</span>].max1, Tree[id * <span class="hljs-number">2</span>].max0);<br>        <span class="hljs-built_in">swap</span>(Tree[id * <span class="hljs-number">2</span>].l1_1, Tree[id * <span class="hljs-number">2</span>].l1_0);<br>        <span class="hljs-built_in">swap</span>(Tree[id * <span class="hljs-number">2</span>].r1_1, Tree[id * <span class="hljs-number">2</span>].r1_0);<br>        Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].sum = (Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r - Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l + <span class="hljs-number">1</span>) - Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].sum;<br>        <span class="hljs-built_in">swap</span>(Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].max1, Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].max0);<br>        <span class="hljs-built_in">swap</span>(Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l1_1, Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l1_0);<br>        <span class="hljs-built_in">swap</span>(Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r1_1, Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].r1_0);<br>    &#125;<br>    Tree[id].lazy = <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(ll id, ll l, ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree[id].l = l;<br>    Tree[id].r = r;<br>    Tree[id].lazy = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (l == r)<br>    &#123;<br>        Tree[id].max1 = Tree[id].sum = Tree[id].l1_1 = Tree[id].r1_1 = a[l];<br>        Tree[id].max0 = Tree[id].l1_0 = Tree[id].r1_0 = <span class="hljs-number">1</span> - a[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ll mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">build</span>(id * <span class="hljs-number">2</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">up</span>(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change1</span><span class="hljs-params">(ll id, ll l, ll r, ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[id].lazy != <span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">down</span>(id);<br>    <span class="hljs-keyword">if</span> (l &lt;= Tree[id].l &amp;&amp; Tree[id].r &lt;= r)<br>    &#123;<br>        Tree[id].lazy = <span class="hljs-built_in">change</span>(Tree[id].lazy, x);<br>        Tree[id].max1 = Tree[id].l1_1 = Tree[id].r1_1 = Tree[id].sum = (Tree[id].r - Tree[id].l + <span class="hljs-number">1</span>) * x;<br>        Tree[id].max0 = Tree[id].l1_0 = Tree[id].r1_0 = (Tree[id].r - Tree[id].l + <span class="hljs-number">1</span>) * (<span class="hljs-number">1</span> - x);<br>        <span class="hljs-comment">// cout&lt;&lt;Tree[id].l&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].r&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].l1&lt;&lt;endl;</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ll mid = (Tree[id].l + Tree[id].r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        <span class="hljs-built_in">change1</span>(id * <span class="hljs-number">2</span>, l, r, x);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        <span class="hljs-built_in">change1</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r, x);<br>    <span class="hljs-built_in">up</span>(id);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change2</span><span class="hljs-params">(ll id, ll l, ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[id].lazy != <span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">down</span>(id);<br>    <span class="hljs-keyword">if</span> (l &lt;= Tree[id].l &amp;&amp; Tree[id].r &lt;= r)<br>    &#123;<br>        Tree[id].lazy = <span class="hljs-built_in">change</span>(Tree[id].lazy, <span class="hljs-number">2</span>);<br>        Tree[id].sum = (Tree[id].r - Tree[id].l + <span class="hljs-number">1</span>) - Tree[id].sum;<br>        <span class="hljs-built_in">swap</span>(Tree[id].max1, Tree[id].max0);<br>        <span class="hljs-built_in">swap</span>(Tree[id].l1_1, Tree[id].l1_0);<br>        <span class="hljs-built_in">swap</span>(Tree[id].r1_1, Tree[id].r1_0);<br>        <span class="hljs-comment">// cout&lt;&lt;Tree[id].l&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].r&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].l1&lt;&lt;endl;</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    ll mid = (Tree[id].l + Tree[id].r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        <span class="hljs-built_in">change2</span>(id * <span class="hljs-number">2</span>, l, r);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        <span class="hljs-built_in">change2</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-built_in">up</span>(id);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">GetSum1</span><span class="hljs-params">(ll id, ll l, ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[id].lazy != <span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">down</span>(id);<br>    <span class="hljs-keyword">if</span> (l &lt;= Tree[id].l &amp;&amp; r &gt;= Tree[id].r)<br>    &#123;<br>        <span class="hljs-comment">// cout&lt;&lt;Tree[id].l&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].r&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].sum&lt;&lt;endl;</span><br>        <span class="hljs-keyword">return</span> Tree[id].sum;<br>    &#125;<br>    ll mid = (Tree[id].l + Tree[id].r) / <span class="hljs-number">2</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        ans += <span class="hljs-built_in">GetSum1</span>(id * <span class="hljs-number">2</span>, l, r);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        ans += <span class="hljs-built_in">GetSum1</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-comment">// cout&lt;&lt;Tree[id].l&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].r&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">GetSum2</span><span class="hljs-params">(ll id, ll l, ll r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (Tree[id].lazy != <span class="hljs-number">-1</span>)<br>        <span class="hljs-built_in">down</span>(id);<br>    <span class="hljs-keyword">if</span> (l &lt;= Tree[id].l &amp;&amp; r &gt;= Tree[id].r)<br>    &#123;<br>        <span class="hljs-keyword">return</span> Tree[id].max1;<br>    &#125;<br>    ll mid = (Tree[id].l + Tree[id].r) / <span class="hljs-number">2</span>, sum = <span class="hljs-number">0</span>, sum1 = <span class="hljs-number">0</span>, sum2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (l &lt;= mid)<br>        sum = <span class="hljs-built_in">GetSum2</span>(id * <span class="hljs-number">2</span>, l, r);<br>    <span class="hljs-keyword">if</span> (r &gt; mid)<br>        sum1 = <span class="hljs-built_in">GetSum2</span>(id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span> (l &lt;= Tree[id * <span class="hljs-number">2</span>].r &amp;&amp; r &gt;= Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l)<br>    &#123;<br>        ll len = Tree[id * <span class="hljs-number">2</span>].r - l + <span class="hljs-number">1</span>;<br>        ll len1 = r - Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l + <span class="hljs-number">1</span>;<br>        ll res = <span class="hljs-built_in">min</span>(Tree[id * <span class="hljs-number">2</span>].r1_1, len);<br>        ll res1 = <span class="hljs-built_in">min</span>(Tree[id * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>].l1_1, len1);<br>        sum2 = res + res1;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(sum, <span class="hljs-built_in">max</span>(sum1, sum2));<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">void prt(ll id,ll l,ll r)&#123;</span><br><span class="hljs-comment">    if(l==r)&#123;</span><br><span class="hljs-comment">        cout&lt;&lt;Tree[id].l&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].r&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].sum&lt;&lt;endl;</span><br><span class="hljs-comment">        //if(Tree[id].l1&lt;=0)Tree[id].l1=0;</span><br><span class="hljs-comment">        //if(Tree[id].r1&lt;=0)Tree[id].r1=0;</span><br><span class="hljs-comment">        return;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    ll mid=(l+r)/2;</span><br><span class="hljs-comment">    prt(id*2,l,mid);</span><br><span class="hljs-comment">    prt(id*2+1,mid+1,r);</span><br><span class="hljs-comment">    cout&lt;&lt;Tree[id].l&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].r&lt;&lt;&quot; &quot;&lt;&lt;Tree[id].sum&lt;&lt;endl;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// freopen(&quot;sb.txt&quot;,&quot;w&quot;,stdout);</span><br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">while</span> (m--)<br>    &#123;<br>        cin &gt;&gt; flag &gt;&gt; a_ &gt;&gt; b_;<br>        a_++;<br>        b_++;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">change1</span>(<span class="hljs-number">1</span>, a_, b_, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">change1</span>(<span class="hljs-number">1</span>, a_, b_, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-built_in">change2</span>(<span class="hljs-number">1</span>, a_, b_);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">3</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">GetSum1</span>(<span class="hljs-number">1</span>, a_, b_) &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">4</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">GetSum2</span>(<span class="hljs-number">1</span>, a_, b_) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/record/115758452">AC Link</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
